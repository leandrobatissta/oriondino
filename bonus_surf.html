<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>Orion & Yasminn ‚Äî B√¥nus Surf</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
body{background:#000;overflow:hidden;font-family:system-ui;}
.wrap{display:grid;place-items:center;height:100%;gap:12px;padding:12px}
.stack{position:relative;width:100%;max-width:900px}
#game{width:100%;aspect-ratio:2/3;max-height:92vh;background:#000;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.35);display:block;touch-action:manipulation}
canvas{
  display:block;
  image-rendering:pixelated;
  image-rendering:-moz-crisp-edges;
  image-rendering:crisp-edges;
}
</style>
</head>
<body>
<div class="wrap">
  <div class="stack">
    <canvas id="game"></canvas>
  </div>
</div>

<!-- √Åudios do jogo principal -->
<audio id="introSound" src="assets/intro.mp3" preload="auto"></audio>
<audio id="bgMusic" src="assets/bg_music.mp3" preload="auto" loop></audio>
<audio id="jumpSound" src="assets/jump.mp3" preload="auto"></audio>
<audio id="hitSound" src="assets/hit.mp3" preload="auto"></audio>
<audio id="pointSound" src="assets/point.mp3" preload="auto"></audio>
<audio id="phaseSound" src="assets/phase_up.mp3" preload="auto"></audio>

<script>
const cvs = document.getElementById('game');

/* üîß CORRE√á√ÉO CR√çTICA: alpha PRECISA ser true */
const ctx = cvs.getContext('2d');
ctx.imageSmoothingEnabled = false;

function fit(){
  const dpr=Math.max(1,Math.min(window.devicePixelRatio||1,2));
  const w=cvs.clientWidth,h=cvs.clientHeight;
  cvs.width=Math.round(w*dpr); cvs.height=Math.round(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
new ResizeObserver(fit).observe(cvs); fit();

// ----- CONFIGURA√á√ïES -----
const GROUND_Y = 0.72;
const WATER_Y  = 0.75;
const SURFER_Y = 0.75;
const WAVE_SPEED = 0.12;
const WAVE_AMPLITUDE = 12;
const WAVE_PUSH_DIST = 0.12;

// Posi√ß√£o do jogador ajustada para mobile
function updatePlayerPosition(){
  const w = cvs.clientWidth;
  if(w < 600){
    PLAYER_X = Math.round(w*0.20); // mais √† esquerda em mobile
  } else if(w < 800){
    PLAYER_X = Math.round(w*0.25); // intermedi√°rio
  } else {
    PLAYER_X = Math.round(w*0.35); // posi√ß√£o normal em desktop
  }
}

let PLAYER_X = Math.round(cvs.clientWidth*0.35);
new ResizeObserver(()=>{ 
  updatePlayerPosition(); 
}).observe(cvs);

// Constantes baseadas no jogo principal
const UNIT = () => Math.max(6, Math.round(cvs.clientHeight/30));
const GY = () => Math.round(cvs.clientHeight*0.80);

// ----- SPRITES -----
const SPRITE_FILES = [
  './sprite3.png',
  './sprite4.png', 
  './sprite5.png'
];

let currentSpriteIndex = 0;
let SPRITE = new Image();
SPRITE.src = SPRITE_FILES[currentSpriteIndex];

function changeRandomSprite() {
  currentSpriteIndex = Math.floor(Math.random() * SPRITE_FILES.length);
  SPRITE.src = SPRITE_FILES[currentSpriteIndex];
  console.log('Mudando para sprite:', SPRITE_FILES[currentSpriteIndex]);
}

// Carregar sprite inicial
SPRITE.onload = () => {
  state.spriteLoaded = true;
  console.log('Sprite carregado:', SPRITE_FILES[currentSpriteIndex]);
};

const OBSTACLE_SPRITE = new Image();
OBSTACLE_SPRITE.src = './obstaculos.png';

// ----- √ÅUDIOS -----
const introSound = document.getElementById('introSound');
const bgMusic = document.getElementById('bgMusic');
const jumpSound = document.getElementById('jumpSound');
const hitSound = document.getElementById('hitSound');
const pointSound = document.getElementById('pointSound');
const phaseSound = document.getElementById('phaseSound');

function safePlay(el){
  if(!el) return;
  try { el.currentTime = 0; } catch(_) {}
  el.play().catch(_=>{});
}

const SPR_COLS = 5;
const SPR_ROWS = 4;
const OBS_COLS = 1;
const OBS_ROWS = 3;

function spriteCellSize(){
  return {
    sw: SPRITE.naturalWidth  / SPR_COLS,
    sh: SPRITE.naturalHeight / SPR_ROWS
  };
}

function obstacleCellSize(){
  return {
    ow: OBSTACLE_SPRITE.naturalWidth / OBS_COLS,
    oh: OBSTACLE_SPRITE.naturalHeight / OBS_ROWS
  };
}

// ----- ESTADO -----
const state = {
  mode: 'run',    // 'run' | 'surf'
  t: 0,
  waveX: -0.5, // posi√ß√£o original (come√ßa da esquerda)
  wavePhase: 0,
  surferX: 0.05, // agora relativo ao mundo
  surferY: 0,
  jumpY: 0, // altura do pulo
  jumpVelocity: 0, // velocidade do pulo
  isJumping: false, // se est√° pulando
  jumpTilt: 0, // inclina√ß√£o durante o pulo
  onWave: false,
  surfFrame: 0,
  runFrame: 0,
  surfAnimDone: false,
  surfAltTime: 0,
  obstacles: [],
  nextObstacleTime: 0, // criar imediatamente no in√≠cio
  spriteLoaded: false,
  obstacleSpriteLoaded: false,
  worldSpeed: UNIT() * 0.08, // velocidade do mundo
  worldOffset: 0, // offset do mundo para movimento
  
  // Fases do jogo principal
  score: 0,
  phase: 0,
  phaseOverlay: 0,
  lastPointAt: 0,
  nextPhaseAt: 10,
  
  // Estado do jogo principal salvo
  savedGame: null,
  gameOver: false,
  lives: 3, // vidas para o HUD
  maxLives: 3
};

SPRITE.onload = () => {
  state.spriteLoaded = true;
  console.log('sprite5.png carregado');
};

OBSTACLE_SPRITE.onload = () => {
  state.obstacleSpriteLoaded = true;
  console.log('obstaculos.png carregado');
  
  // Carregar estado salvo do jogo principal
  try {
    const saved = JSON.parse(localStorage.getItem('surf_bonus_return') || '{}');
    if(saved && saved.character) {
      state.savedGame = saved;
      state.score = saved.score || 0;
      state.lives = saved.lives || 3;
      state.maxLives = saved.maxLives || 3;
      console.log('Estado do jogo principal carregado');
    }
  } catch(e) {
    console.log('Nenhum estado salvo encontrado');
  }
  
  // Sortear sprite inicial
  changeRandomSprite();
  
  // Criar 2 obst√°culos iniciais como antes
  state.obstacles.push(createObstacle());
  state.obstacles[0].x = 3.0; // primeiro obst√°culo
  state.obstacles[0].speed = 0.15; // velocidade base
  
  state.obstacles.push(createObstacle());
  state.obstacles[1].x = 5.0; // segundo obst√°culo mais √† direita
  state.obstacles[1].speed = 0.15; // mesma velocidade base
  
  // Iniciar m√∫sica de fundo
  safePlay(bgMusic);
};

// ----- CONTROLES DE PULO -----
cvs.addEventListener('click', (e) => {
  if(state.mode === 'surf' && !state.isJumping && !state.gameOver){
    state.isJumping = true;
    state.jumpVelocity = -1.2; // velocidade ajustada
    state.jumpTilt = -0.2; // inclina√ß√£o inicial para frente (negativo)
    state.jumpY = 0.01; // come√ßa um pouco acima
    safePlay(jumpSound); // som do pulo
  }
});

window.addEventListener('keydown', (e) => {
  if(e.code === 'Space' && state.mode === 'surf' && !state.isJumping && !state.gameOver){
    e.preventDefault();
    state.isJumping = true;
    state.jumpVelocity = -1.2; // velocidade ajustada
    state.jumpTilt = -0.2; // inclina√ß√£o inicial para frente (negativo)
    state.jumpY = 0.01; // come√ßa um pouco acima
    safePlay(jumpSound); // som do pulo
  }
});

// ----- UTILS -----
const lerp = (a,b,t)=>a+(b-a)*t;

// ----- OBST√ÅCULOS -----
function createObstacle(){
  const types = [0, 1, 2]; // 3 tipos de obst√°culos
  return {
    type: types[Math.floor(Math.random() * types.length)],
    x: 3.0, // sempre fora da tela (direita)
    y: Math.random() * 0.1 - 0.05, // leve varia√ß√£o Y
    phase: Math.random() * Math.PI * 2, // fase inicial para movimento Y
    speed: 0.15, // velocidade base (ser√° ajustada no spawn)
    passed: false // para controle de pontos
  };
}

function drawObstacles(w,h){
  if(!state.obstacleSpriteLoaded) return;
  
  const {ow,oh} = obstacleCellSize();
  
  // Ajustar tamanho dos obst√°culos para mobile
  const isMobile = w < 600;
  const obstacleScale = isMobile ? 0.6 : 1.0; // muito menor em mobile
  
  state.obstacles.forEach(obs => {
    // Converter coordenadas do mundo para tela
    const screenX = (obs.x - state.surferX) * cvs.clientWidth + PLAYER_X;
    const yOffset = Math.sin(obs.phase) * 12; // movimento Y da onda
    
    ctx.drawImage(
      OBSTACLE_SPRITE,
      obs.type * ow, 0, ow, oh,
      screenX, h*WATER_Y - oh*0.05 + yOffset,
      ow*obstacleScale, oh*obstacleScale // tamanho ajustado
    );
  });
}

// ----- DESENHO -----
function drawSky(w,h){
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0,'#38bdf8');
  g.addColorStop(1,'#f0f9ff');
  ctx.fillStyle=g;
  ctx.fillRect(0,0,w,h);
}

function drawBeach(w,h){
  ctx.fillStyle='#fde68a';
  ctx.fillRect(0,h*GROUND_Y,w,h);
  ctx.fillStyle='#0ea5e9';
  ctx.fillRect(0,h*WATER_Y,w,h);
}

function drawSun(w,h){
  // Sol mais pr√≥ximo ao personagem e menor em mobile
  const sunX = w < 600 ? w*0.65 : w*0.75; // mais pr√≥ximo do personagem
  const sunY = w < 600 ? h*0.10 : h*0.12; // mais alto em telas pequenas
  const sunR = w < 600 ? Math.min(25, Math.min(w,h)*0.05) : Math.min(48, Math.min(w,h)*0.10); // bem menor em mobile
  
  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = '#ffd700';
  ctx.beginPath(); ctx.arc(sunX, sunY, sunR, 0, Math.PI*2); ctx.fill();
  ctx.globalAlpha = 0.3;
  ctx.fillStyle = '#ffed4e';
  ctx.beginPath(); ctx.arc(sunX, sunY, sunR*1.4, 0, Math.PI*2); ctx.fill();
  ctx.restore();
}

function drawWave(w,h){
  if(!state.spriteLoaded) return;

  const {sw,sh}=spriteCellSize();
  const row = Math.floor(state.wavePhase*1.5) % 2; // alterna linhas 1 e 2
  let frame = Math.floor(state.wavePhase*5) % SPR_COLS;
  // descarta 1¬∫ frame da linha 1 (ruim)
  if(row === 0 && frame === 0) frame = 1;
  const sx = frame*sw;
  const sy = row*sh;

  // Converter coordenadas de mundo para tela
  const waveScreenX = (state.waveX - state.surferX) * w + PLAYER_X;

  // onda mais √† esquerda (atr√°s da prancha), com mais afastamento
  const dx = waveScreenX - sw*0.30; // mais longe do surfista (aumentado de 0.25 para 0.30)
  const dy = h*WATER_Y + Math.sin(state.wavePhase)*WAVE_AMPLITUDE - sh*0.57; // volta √† posi√ß√£o original

  ctx.drawImage(
    SPRITE,
    sx, sy, sw, sh,
    dx, dy,
    sw*1.1, sh*1.1 - 1  // remove 1 pixel da altura
  );
}

function drawRunner(w,h){
  if(!state.spriteLoaded) return;

  const {sw,sh}=spriteCellSize();
  let frame = Math.floor(state.runFrame) % SPR_COLS;
  // ignora o 1¬∫ frame da corrida (ruim)
  if(frame === 0) frame = 1;
  const sx = frame*sw + 3; // corta 3 pixels da esquerda
  const sy = 2*sh; // linha 3 (corrida)

  // Ajustar tamanho do personagem para mobile
  const isMobile = w < 600;
  const scale = isMobile ? 0.7 : 0.55; // maior em mobile

  // Corredor sempre na posi√ß√£o fixa do jogador
  const dx = PLAYER_X - sw*0.15;
  const dy = h*GROUND_Y - sh*0.35;

  ctx.drawImage(
    SPRITE,
    sx, sy, sw - 3, sh, // remove 3 pixels de cada lado
    dx, dy,
    sw*scale, sh*scale // tamanho ajustado
  );
}

function drawSurfer(w,h){
  if(!state.spriteLoaded) return;

  const {sw,sh}=spriteCellSize();
  const frame = Math.floor(state.surfFrame) % SPR_COLS;
  const sx = frame*sw + 3; // corta 3 pixels da esquerda
  const sy = 3*sh; // linha 4 (subindo na prancha / surf)

  // Ajustar tamanho do personagem para mobile - muito menor agora
  const isMobile = w < 600;
  const scale = isMobile ? 0.45 : 0.55; // bem menor em mobile
  
  // Surfista sempre na posi√ß√£o fixa do jogador
  const dx = PLAYER_X - sw*0.15;
  const dy = h*SURFER_Y - sh*0.35 + state.surferY - (state.jumpY * h * 0.3);

  ctx.save();
  
  // Aplicar inclina√ß√£o durante o pulo
  if(state.isJumping){
    ctx.translate(dx + sw*0.275, dy + sh*0.275); // centro do sprite
    ctx.rotate(state.jumpTilt); // inclina√ß√£o
    ctx.translate(-(dx + sw*0.275), -(dy + sh*0.275));
  }

  ctx.drawImage(
    SPRITE,
    sx, sy, sw - 3, sh, // remove 3 pixels de cada lado
    dx, dy,
    sw*scale, sh*scale // tamanho ajustado
  );
  
  ctx.restore();
}

// ----- UPDATE -----
function update(dt){
  state.t+=dt;

  // spawn de obst√°culos durante o surf - sem limite, velocidade progressiva
  if(state.mode === 'surf' && state.t >= state.nextObstacleTime){
    const newObstacle = createObstacle();
    newObstacle.x = 3.0 + Math.random() * 2.0; // sempre entre 3.0 e 5.0 (fora da tela)
    
    // Aumentar velocidade baseada na quantidade de obst√°culos existentes
    const speedIncrease = state.obstacles.length * 0.02; // 0.02 por obst√°culo
    newObstacle.speed = 0.15 + speedIncrease;
    
    state.obstacles.push(newObstacle);
    state.nextObstacleTime = state.t + 3; // 3 segundos entre spawns (mais r√°pido)
  }

  // atualizar obst√°culos (movimento do mundo) - NUNCA REMOVER
  state.obstacles.forEach(obs => {
    obs.x -= dt * obs.speed; // move da direita para esquerda no mundo
    obs.phase += dt * 2; // movimento Y
    
    // Verificar colis√£o com o surfista - MELHORADA
    if(state.mode === 'surf' && !state.gameOver) {
      const obsScreenX = (obs.x - state.surferX) * cvs.clientWidth + PLAYER_X;
      const obsY = cvs.clientHeight*WATER_Y - 32*0.05 + Math.sin(obs.phase) * 12;
      
      const surferX = PLAYER_X;
      const surferY = cvs.clientHeight*SURFER_Y - 32*0.35 + state.surferY - (state.jumpY * cvs.clientHeight * 0.3);
      
      // Ajustar hitbox para mobile
      const isMobile = cvs.clientWidth < 600;
      const hitboxScale = isMobile ? 0.6 : 1.0;
      
      // Hitbox mais precisa
      const surferHitbox = {
        x: surferX + 5,
        y: surferY + 5,
        w: 22 * hitboxScale,
        h: 22 * hitboxScale
      };
      
      const obsHitbox = {
        x: obsScreenX + 4,
        y: obsY + 4,
        w: 24 * hitboxScale,
        h: 24 * hitboxScale
      };
      
      // Verificar colis√£o
      if(obsHitbox.x < surferHitbox.x + surferHitbox.w &&
         obsHitbox.x + obsHitbox.w > surferHitbox.x &&
         obsHitbox.y < surferHitbox.y + surferHitbox.h &&
         obsHitbox.y + obsHitbox.h > surferHitbox.y) {
        
        // Perder uma vida
        state.lives--;
        safePlay(hitSound);
        
        if(state.lives <= 0) {
          // Game over!
          state.gameOver = true;
          
          // Salvar estado final
          const finalState = {
            ...state.savedGame,
            score: state.score,
            lives: 0,
            bonusSurfCompleted: false
          };
          
          // Salvar e redirecionar
          localStorage.setItem('surf_bonus_return', JSON.stringify(finalState));
          
          setTimeout(() => {
            window.location.href = './return_from_surf.html';
          }, 1000);
          return;
        } else {
          // Resetar obst√°culo que colidiu
          obs.x = 3.0 + Math.random() * 2.0;
          obs.passed = false;
        }
      }
    }
    
    // Verificar se passou pelo jogador (ponto)
    if(!obs.passed && obs.x < state.surferX){
      obs.passed = true;
      state.score++;
      
      // Som de ponto
      const tNow = performance.now();
      if(tNow - state.lastPointAt > 80) {
        safePlay(pointSound);
        state.lastPointAt = tNow;
      }
      
      // Verificar pr√≥xima fase
      if(state.score >= state.nextPhaseAt) {
        state.phase = Math.min(5, state.phase + 1); // m√°ximo 5 fases
        state.phaseOverlay = 4.4;
        state.nextPhaseAt += 10;
        safePlay(phaseSound);
        
        // Mudar sprite aleatoriamente a cada fase
        changeRandomSprite();
        
        // Aumentar velocidade dos obst√°culos com a fase
        state.obstacles.forEach(o => {
          o.speed = 0.15 + (state.phase * 0.02); // aumenta 0.02 por fase
        });
      }
    }
    
    // Se sair da tela, volta para o come√ßo (sem reset)
    if(obs.x < -2.0){
      obs.x = 3.0 + Math.random() * 2.0; // volta para fora da tela
      obs.passed = false; // reset para poder pontuar novamente
    }
  });

  if(state.mode==='run'){
    state.runFrame+=dt*12;
    if(state.runFrame >= 5) state.runFrame = 0; // reset de frame
    
    // Personagem se move no mundo, mas fica fixo na tela
    state.surferX = Math.min(0.35, state.surferX + dt*0.015);
    
    // Onda se aproxima no mundo (l√≥gica original)
    state.waveX+=dt*WAVE_SPEED;
    state.wavePhase+=dt*1.5;

    // Transi√ß√£o mais segura
    const waveDistance = Math.abs(state.waveX - state.surferX);
    if(waveDistance < 0.08){ // dist√¢ncia segura para transi√ß√£o
      state.mode='surf';
      state.onWave=true;
      state.surfFrame = 0;
      state.surfAnimDone = false;
      state.surfAltTime = state.t;
      console.log('Transi√ß√£o para surf mode - dist√¢ncia:', waveDistance.toFixed(3));
    }
  }

  if(state.mode === 'surf'){
    state.waveX+=dt*WAVE_SPEED;
    // REMOVIDO: reset da onda - agora continua infinitamente
    state.wavePhase+=dt*1.5;
    
    // F√≠sica do pulo com inclina√ß√£o
    if(state.isJumping){
      state.jumpVelocity += 2.0 * dt; // gravidade
      state.jumpY -= state.jumpVelocity * dt; // movimento vertical
      
      // Inclina√ß√£o durante o pulo (frente = negativo)
      if(state.jumpVelocity < 0){
        state.jumpTilt = Math.max(-0.3, state.jumpTilt - dt * 3); // inclina mais para frente
      } else {
        state.jumpTilt = Math.min(0, state.jumpTilt + dt * 3); // volta inclina√ß√£o para normal
      }
      
      // Verificar se aterrissou
      if(state.jumpY <= 0){
        state.jumpY = 0;
        state.jumpVelocity = 0;
        state.isJumping = false;
        state.jumpTilt = 0;
      }
    }
    
    // Onda empurra o surfista no mundo
    state.surferX = lerp(state.surferX, state.waveX + WAVE_PUSH_DIST + 0.15, dt * 2);
    state.surferY = Math.sin(state.wavePhase) * WAVE_AMPLITUDE;

    if(!state.surfAnimDone){
      state.surfFrame += dt * 3;
      
      // L√≥gica segura de frames
      if(state.surfFrame >= 1 && state.surfFrame < 3){
        state.surfFrame = 3; // pula para o frame 3
      }
      if(state.surfFrame >= 4){
        state.surfFrame = 4; // para no √∫ltimo quadro
        state.surfAnimDone = true;
        state.surfAltTime = state.t;
        console.log('Anima√ß√£o de surf conclu√≠da - frame final:', state.surfFrame);
      }
    } else {
      // intercala automaticamente entre frames 3 e 4 uma vez por segundo
      if(state.t - state.surfAltTime >= 1){
        state.surfFrame = state.surfFrame === 4 ? 3 : 4;
        state.surfAltTime = state.t;
      }
    }
  }
}

// ----- LOOP -----
let last=performance.now();
function loop(now){
  const dt=Math.min(0.032,(now-last)/1000); last=now;
  
  update(dt);

  const w=cvs.clientWidth, h=cvs.clientHeight;

  // fundo
  drawSky(w,h);
  drawSun(w,h); // sol do jogo principal
  drawBeach(w,h);

  // onda desenha em todos os modos (vem de tr√°s)
  drawWave(w,h);

  // obst√°culos (atr√°s do surfista)
  drawObstacles(w,h);

  // personagem na frente (sempre fixo na tela)
  if(state.mode==='run'){
    drawRunner(w,h);
  } else {
    drawSurfer(w,h);
  }

  // debug removido para mobile
  
  // HUD de vidas - ajustado para mobile
  const isMobile = w < 600;
  ctx.fillStyle = '#fff';
  ctx.font = isMobile ? '12px system-ui' : '16px system-ui';
  ctx.textAlign = 'left';
  ctx.fillText('Vidas: ', w - (isMobile ? 120 : 150), isMobile ? 25 : 30);
  
  // Desenhar cora√ß√µes - menores em mobile
  const heartSize = isMobile ? 15 : 25;
  const heartSpacing = isMobile ? 18 : 25;
  for(let i = 0; i < state.maxLives; i++){
    const x = w - (isMobile ? 60 : 80) + i * heartSpacing;
    const y = isMobile ? 15 : 20;
    
    if(i < state.lives){
      // Cora√ß√£o cheio
      ctx.fillStyle = '#ff4444';
      ctx.beginPath();
      ctx.moveTo(x + heartSize*0.32, y + heartSize*0.24);
      ctx.bezierCurveTo(x + heartSize*0.32, y + heartSize*0.08, x + heartSize*0.16, y + heartSize*0.08, x + heartSize*0.16, y + heartSize*0.24);
      ctx.bezierCurveTo(x + heartSize*0.16, y + heartSize*0.40, x + heartSize*0.32, y + heartSize*0.56, x + heartSize*0.48, y + heartSize*0.56);
      ctx.bezierCurveTo(x + heartSize*0.64, y + heartSize*0.56, x + heartSize*0.80, y + heartSize*0.40, x + heartSize*0.80, y + heartSize*0.24);
      ctx.bezierCurveTo(x + heartSize*0.80, y + heartSize*0.08, x + heartSize*0.64, y + heartSize*0.08, x + heartSize*0.48, y + heartSize*0.24);
      ctx.bezierCurveTo(x + heartSize*0.40, y + heartSize*0.32, x + heartSize*0.32, y + heartSize*0.24, x + heartSize*0.32, y + heartSize*0.24);
      ctx.fill();
    } else {
      // Cora√ß√£o vazio
      ctx.strokeStyle = '#ff4444';
      ctx.lineWidth = isMobile ? 1 : 2;
      ctx.beginPath();
      ctx.moveTo(x + heartSize*0.32, y + heartSize*0.24);
      ctx.bezierCurveTo(x + heartSize*0.32, y + heartSize*0.08, x + heartSize*0.16, y + heartSize*0.08, x + heartSize*0.16, y + heartSize*0.24);
      ctx.bezierCurveTo(x + heartSize*0.16, y + heartSize*0.40, x + heartSize*0.32, y + heartSize*0.56, x + heartSize*0.48, y + heartSize*0.56);
      ctx.bezierCurveTo(x + heartSize*0.64, y + heartSize*0.56, x + heartSize*0.80, y + heartSize*0.40, x + heartSize*0.80, y + heartSize*0.24);
      ctx.bezierCurveTo(x + heartSize*0.80, y + heartSize*0.08, x + heartSize*0.64, y + heartSize*0.08, x + heartSize*0.48, y + heartSize*0.24);
      ctx.bezierCurveTo(x + heartSize*0.40, y + heartSize*0.32, x + heartSize*0.32, y + heartSize*0.24, x + heartSize*0.32, y + heartSize*0.24);
      ctx.stroke();
    }
  }
  
  // Overlay de game over - ajustado para mobile
  if(state.gameOver){
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(0,0,w,h);
    ctx.fillStyle = '#fff';
    ctx.font = isMobile ? 'bold 32px system-ui' : 'bold 48px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', w/2, h/2);
    ctx.font = isMobile ? '18px system-ui' : '24px system-ui';
    ctx.fillText(`Score Final: ${state.score}`, w/2, h/2 + (isMobile ? 40 : 60));
    ctx.restore();
  }
  
  // Overlay de fase - ajustado para mobile
  if(state.phaseOverlay > 0){
    ctx.save();
    ctx.globalAlpha = Math.min(1, state.phaseOverlay);
    ctx.fillStyle = '#fff';
    
    // Ajustar tamanho da fonte para mobile
    const fontSize = isMobile ? '28px' : '48px';
    ctx.font = `bold ${fontSize} system-ui`;
    ctx.textAlign = 'center';
    ctx.fillText(`FASE ${state.phase + 1}`, w/2, h/2);
    ctx.restore();
    state.phaseOverlay -= dt;
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>