<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>Orion & Yasminn ‚Äî B√¥nus Surf</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
body{background:#0ea5e9;overflow:hidden;font-family:system-ui;}
canvas{
  display:block;
  image-rendering:pixelated;
  image-rendering:-moz-crisp-edges;
  image-rendering:crisp-edges;
}
</style>
</head>
<body>
<canvas id="cvs"></canvas>

<script>
const cvs = document.getElementById('cvs');

/* üîß CORRE√á√ÉO CR√çTICA: alpha PRECISA ser true */
const ctx = cvs.getContext('2d');
ctx.imageSmoothingEnabled = false;

// ----- CONFIGURA√á√ïES -----
const GROUND_Y = 0.72;
const WATER_Y  = 0.75; // subiu 3 pixels (0.78 ‚Üí 0.75)
const SURFER_Y = 0.75;
const WAVE_SPEED = 0.12;
const WAVE_AMPLITUDE = 12;
const WAVE_PUSH_DIST = 0.12;

// ----- SPRITES -----
const SPRITE = new Image();
SPRITE.src = './sprite5.png'; // üîß caminho expl√≠cito

const OBSTACLE_SPRITE = new Image();
OBSTACLE_SPRITE.src = './obstaculos.png';

const SPR_COLS = 5;
const SPR_ROWS = 4;
const OBS_COLS = 1; // 3 obst√°culos em coluna
const OBS_ROWS = 3;

function spriteCellSize(){
  return {
    sw: SPRITE.naturalWidth  / SPR_COLS,
    sh: SPRITE.naturalHeight / SPR_ROWS
  };
}

function obstacleCellSize(){
  return {
    ow: OBSTACLE_SPRITE.naturalWidth / OBS_COLS,
    oh: OBSTACLE_SPRITE.naturalHeight / OBS_ROWS
  };
}

// ----- ESTADO -----
const state = {
  mode: 'run',    // 'run' | 'surf'
  t: 0,
  waveX: -0.5,
  wavePhase: 0,
  surferX: 0.05,
  surferY: 0,
  onWave: false,
  surfFrame: 0,
  runFrame: 0,
  surfAnimDone: false, // controle se anima√ß√£o terminou
  surfAltTime: 0, // controle para altern√¢ncia autom√°tica
  obstacles: [], // array de obst√°culos
  nextObstacleTime: 2, // pr√≥ximo obst√°culo em 2s
  spriteLoaded: false,
  obstacleSpriteLoaded: false
};

SPRITE.onload = () => {
  state.spriteLoaded = true;
  console.log('sprite5.png carregado');
};

OBSTACLE_SPRITE.onload = () => {
  state.obstacleSpriteLoaded = true;
  console.log('obstaculos.png carregado');
};

// ----- CANVAS -----
function resize(){
  cvs.width = innerWidth;
  cvs.height = innerHeight;
}
addEventListener('resize', resize);
resize();

// ----- UTILS -----
const lerp = (a,b,t)=>a+(b-a)*t;

// ----- OBST√ÅCULOS -----
function createObstacle(){
  const types = [0, 1, 2]; // 3 tipos de obst√°culos
  return {
    type: types[Math.floor(Math.random() * types.length)],
    x: 1.2, // come√ßa da direita
    y: Math.random() * 0.1 - 0.05, // leve varia√ß√£o Y
    phase: Math.random() * Math.PI * 2, // fase inicial para movimento Y
    speed: 0.08 + Math.random() * 0.04 // velocidade aleat√≥ria
  };
}

function drawObstacles(w,h){
  if(!state.obstacleSpriteLoaded) return;
  
  const {ow,oh} = obstacleCellSize();
  
  state.obstacles.forEach(obs => {
    const sx = 0; // s√≥ uma coluna
    const sy = obs.type * oh;
    
    // movimento suave no eixo Y (aumentado)
    const yOffset = Math.sin(obs.phase) * 12; // mais movimento Y
    
    ctx.drawImage(
      OBSTACLE_SPRITE,
      sx, sy, ow, oh - 3, // corta 3 pixels de baixo
      w*obs.x,
      h*WATER_Y - oh*0.05 + yOffset, // mais para baixo
      ow*0.25, oh*0.25  // tamanho normal
    );
  });
}

// ----- DESENHO -----
function drawSky(w,h){
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0,'#38bdf8');
  g.addColorStop(1,'#f0f9ff');
  ctx.fillStyle=g;
  ctx.fillRect(0,0,w,h);
}

function drawBeach(w,h){
  ctx.fillStyle='#fde68a';
  ctx.fillRect(0,h*GROUND_Y,w,h);
  ctx.fillStyle='#0ea5e9';
  ctx.fillRect(0,h*WATER_Y,w,h);
}

function drawWave(w,h){
  if(!state.spriteLoaded) return;

  const {sw,sh}=spriteCellSize();
  const row = Math.floor(state.wavePhase*1.5) % 2; // alterna linhas 1 e 2
  let frame = Math.floor(state.wavePhase*5) % SPR_COLS;
  // descarta 1¬∫ frame da linha 1 (ruim)
  if(row === 0 && frame === 0) frame = 1;
  const sx = frame*sw;
  const sy = row*sh;

  // onda mais √† esquerda (atr√°s da prancha), mas um pouco afastada
  const dx = state.waveX*w - sw*0.15; // mais longe do surfista
  const dy = h*WATER_Y + Math.sin(state.wavePhase)*WAVE_AMPLITUDE - sh*0.55; // mais para baixo

  ctx.drawImage(
    SPRITE,
    sx, sy, sw, sh,
    dx, dy,
    sw*1.1, sh*1.1 - 1  // remove 1 pixel da altura
  );
}

function drawRunner(w,h){
  if(!state.spriteLoaded) return;

  const {sw,sh}=spriteCellSize();
  let frame = Math.floor(state.runFrame) % SPR_COLS;
  // ignora o 1¬∫ frame da corrida (ruim)
  if(frame === 0) frame = 1;
  const sx = frame*sw;
  const sy = 2*sh; // linha 3 (corrida)

  ctx.drawImage(
    SPRITE,
    sx + 3, sy, sw - 3, sh, // corta 3 pixels da esquerda
    w*state.surferX,
    h*GROUND_Y - sh*0.55,
    sw*0.55, sh*0.55  // tamanho normal
  );
}

function drawSurfer(w,h){
  if(!state.spriteLoaded) return;

  const {sw,sh}=spriteCellSize();
  const frame = Math.floor(state.surfFrame) % SPR_COLS;
  const sx = frame*sw;
  const sy = 3*sh; // linha 4 (subindo na prancha / surf)

  // surfista um pouco mais √† esquerda (onda passa atr√°s da prancha), mas um pouco afastado
  const dx = w*state.surferX - sw*0.10;
  const dy = h*SURFER_Y - sh*0.35 + state.surferY; // mais baixo, alinhado com onda

  ctx.drawImage(
    SPRITE,
    sx + 3, sy, sw - 3, sh, // corta 3 pixels da esquerda
    dx, dy,
    sw*0.55, sh*0.55  // tamanho normal
  );
}

// ----- UPDATE -----
function update(dt){
  state.t+=dt;

  // spawn de obst√°culos durante o surf
  if(state.mode === 'surf' && state.t >= state.nextObstacleTime){
    state.obstacles.push(createObstacle());
    state.nextObstacleTime = state.t + 2 + Math.random() * 2; // pr√≥ximo em 2-4s
  }

  // atualizar obst√°culos
  state.obstacles = state.obstacles.filter(obs => {
    obs.x -= dt * obs.speed; // move da direita para esquerda
    obs.phase += dt * 2; // movimento Y
    return obs.x > -0.2; // remove se sair da tela
  });

  if(state.mode==='run'){
    state.runFrame+=dt*12;
    // personagem corre devagar para a direita
    state.surferX = Math.min(0.35, state.surferX + dt*0.015);
    // onda se aproxima
    state.waveX+=dt*WAVE_SPEED;
    state.wavePhase+=dt*1.5;

    // quando a onda encosta, j√° entra no surf
    if(state.waveX >= (state.surferX - WAVE_PUSH_DIST)){
      state.mode='surf';
      state.onWave=true;
      state.surfFrame = 0;
      state.surfAnimDone = false;
    }
  }

  if(state.mode==='surf'){
    state.waveX+=dt*WAVE_SPEED;
    if(state.waveX > 1.2) state.waveX = -0.4;
    state.wavePhase+=dt*1.5;

    // onda empurra o surfista, quase sobreposta (empurr√£o m√°ximo)
    state.surferX = lerp(state.surferX, state.waveX + WAVE_PUSH_DIST, dt*2);
    state.surferY = Math.sin(state.wavePhase)*WAVE_AMPLITUDE;

    // anima√ß√£o de surf autom√°tica pulando frames 1 e 2, depois intercala 3‚Üî4
    if(!state.surfAnimDone){
      state.surfFrame+=dt*3; // velocidade normal
      if(state.surfFrame >= 1 && state.surfFrame < 3){
        state.surfFrame = 3; // pula para o frame 3
      }
      if(state.surfFrame >= 4){
        state.surfFrame = 4; // para no √∫ltimo quadro
        state.surfAnimDone = true;
        state.surfAltTime = state.t; // marca in√≠cio da altern√¢ncia
      }
    } else {
      // intercala automaticamente entre frames 3 e 4 uma vez por segundo
      if(state.t - state.surfAltTime >= 1){
        state.surfFrame = state.surfFrame === 4 ? 3 : 4;
        state.surfAltTime = state.t; // reseta tempo
      }
    }
  }
}

// ----- LOOP -----
let last=performance.now();
function loop(now){
  const dt=(now-last)/1000;
  last=now;

  update(dt);

  drawSky(cvs.width,cvs.height);
  drawBeach(cvs.width,cvs.height);

  // onda desenha em todos os modos (vem de tr√°s)
  drawWave(cvs.width,cvs.height);

  // obst√°culos (atr√°s do surfista)
  drawObstacles(cvs.width,cvs.height);

  // personagem na frente
  if(state.mode==='run'){
    drawRunner(cvs.width,cvs.height);
  } else {
    drawSurfer(cvs.width,cvs.height);
  }

  // debug
  ctx.fillStyle='#fff';
  ctx.font='14px system-ui';
  ctx.fillText(state.mode.toUpperCase(),10,20);
  ctx.fillText(`runFrame=${Math.floor(state.runFrame)} surfFrame=${Math.floor(state.surfFrame)}`,10,40);
  ctx.fillText(`Obst√°culos: ${state.obstacles.length}`,10,60);
  if(state.mode==='surf'){
    ctx.fillText(state.onWave?'ON WAVE':'WAITING',10,80);
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>