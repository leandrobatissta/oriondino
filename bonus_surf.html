<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>Orion & Yasminn ‚Äî B√¥nus Surf</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
body{background:#000;overflow:hidden;font-family:system-ui;}
.wrap{display:grid;place-items:center;height:100%;gap:12px;padding:12px}
.stack{position:relative;width:100%;max-width:900px}
#game{width:100%;aspect-ratio:2/3;max-height:92vh;background:#000;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.35);display:block;touch-action:manipulation}
canvas{
  display:block;
  image-rendering:pixelated;
  image-rendering:-moz-crisp-edges;
  image-rendering:crisp-edges;
}
</style>
</head>
<body>
<div class="wrap">
  <div class="stack">
    <canvas id="game"></canvas>
  </div>
</div>

<script>
const cvs = document.getElementById('game');

/* üîß CORRE√á√ÉO CR√çTICA: alpha PRECISA ser true */
const ctx = cvs.getContext('2d');
ctx.imageSmoothingEnabled = false;

function fit(){
  const dpr=Math.max(1,Math.min(window.devicePixelRatio||1,2));
  const w=cvs.clientWidth,h=cvs.clientHeight;
  cvs.width=Math.round(w*dpr); cvs.height=Math.round(h*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
new ResizeObserver(fit).observe(cvs); fit();

// ----- CONFIGURA√á√ïES -----
const GROUND_Y = 0.72;
const WATER_Y  = 0.75;
const SURFER_Y = 0.75;
const WAVE_SPEED = 0.12;
const WAVE_AMPLITUDE = 12;
const WAVE_PUSH_DIST = 0.12;

// Constantes baseadas no jogo principal
const UNIT = () => Math.max(6, Math.round(cvs.clientHeight/30));
const GY = () => Math.round(cvs.clientHeight*0.80);
let PLAYER_X = Math.round(cvs.clientWidth*0.35); // movido para 35% (mais para direita)
new ResizeObserver(()=>{ PLAYER_X = Math.round(cvs.clientWidth*0.35); }).observe(cvs);

// ----- SPRITES -----
const SPRITE = new Image();
SPRITE.src = './sprite5.png';

const OBSTACLE_SPRITE = new Image();
OBSTACLE_SPRITE.src = './obstaculos.png';

const SPR_COLS = 5;
const SPR_ROWS = 4;
const OBS_COLS = 1;
const OBS_ROWS = 3;

function spriteCellSize(){
  return {
    sw: SPRITE.naturalWidth  / SPR_COLS,
    sh: SPRITE.naturalHeight / SPR_ROWS
  };
}

function obstacleCellSize(){
  return {
    ow: OBSTACLE_SPRITE.naturalWidth / OBS_COLS,
    oh: OBSTACLE_SPRITE.naturalHeight / OBS_ROWS
  };
}

// ----- ESTADO -----
const state = {
  mode: 'run',    // 'run' | 'surf'
  t: 0,
  waveX: -0.5, // posi√ß√£o original (come√ßa da esquerda)
  wavePhase: 0,
  surferX: 0.05, // agora relativo ao mundo
  surferY: 0,
  jumpY: 0, // altura do pulo
  jumpVelocity: 0, // velocidade do pulo
  isJumping: false, // se est√° pulando
  jumpTilt: 0, // inclina√ß√£o durante o pulo
  onWave: false,
  surfFrame: 0,
  runFrame: 0,
  surfAnimDone: false,
  surfAltTime: 0,
  obstacles: [],
  nextObstacleTime: 0, // criar imediatamente no in√≠cio
  spriteLoaded: false,
  obstacleSpriteLoaded: false,
  worldSpeed: UNIT() * 0.08, // velocidade do mundo
  worldOffset: 0 // offset do mundo para movimento
};

SPRITE.onload = () => {
  state.spriteLoaded = true;
  console.log('sprite5.png carregado');
};

OBSTACLE_SPRITE.onload = () => {
  state.obstacleSpriteLoaded = true;
  console.log('obstaculos.png carregado');
  
  // Criar apenas 2 obst√°culos iniciais espa√ßados
  state.obstacles.push(createObstacle());
  state.obstacles[0].x = 3.0; // primeiro obst√°culo
  
  state.obstacles.push(createObstacle());
  state.obstacles[1].x = 5.0; // segundo obst√°culo mais √† direita
};

// ----- CONTROLES DE PULO -----
cvs.addEventListener('click', () => {
  if(state.mode === 'surf' && !state.isJumping){
    state.isJumping = true;
    state.jumpVelocity = -1.2; // velocidade ajustada
    state.jumpTilt = -0.2; // inclina√ß√£o inicial para frente (negativo)
    state.jumpY = 0.01; // come√ßa um pouco acima
  }
});

window.addEventListener('keydown', (e) => {
  if(e.code === 'Space' && state.mode === 'surf' && !state.isJumping){
    e.preventDefault();
    state.isJumping = true;
    state.jumpVelocity = -1.2; // velocidade ajustada
    state.jumpTilt = -0.2; // inclina√ß√£o inicial para frente (negativo)
    state.jumpY = 0.01; // come√ßa um pouco acima
  }
});

// ----- UTILS -----
const lerp = (a,b,t)=>a+(b-a)*t;

// ----- OBST√ÅCULOS -----
function createObstacle(){
  const types = [0, 1, 2]; // 3 tipos de obst√°culos
  return {
    type: types[Math.floor(Math.random() * types.length)],
    x: 3.0, // sempre fora da tela (direita)
    y: Math.random() * 0.1 - 0.05, // leve varia√ß√£o Y
    phase: Math.random() * Math.PI * 2, // fase inicial para movimento Y
    speed: 0.15 // velocidade aumentada (mais r√°pido)
  };
}

function drawObstacles(w,h){
  if(!state.obstacleSpriteLoaded) return;
  
  const {ow,oh} = obstacleCellSize();
  
  state.obstacles.forEach(obs => {
    const sx = 0; // s√≥ uma coluna
    const sy = obs.type * oh;
    
    // movimento suave no eixo Y (aumentado)
    const yOffset = Math.sin(obs.phase) * 12; // mais movimento Y
    
    // Converter coordenadas de mundo para tela (corrigido)
    const screenX = (obs.x - state.surferX) * w + PLAYER_X;
    
    ctx.drawImage(
      OBSTACLE_SPRITE,
      sx, sy, ow, oh - 3, // corta 3 pixels de baixo
      screenX,
      h*WATER_Y - oh*0.05 + yOffset, // mais para baixo
      ow*0.25, oh*0.25  // tamanho normal
    );
  });
}

// ----- DESENHO -----
function drawSky(w,h){
  const g = ctx.createLinearGradient(0,0,0,h);
  g.addColorStop(0,'#38bdf8');
  g.addColorStop(1,'#f0f9ff');
  ctx.fillStyle=g;
  ctx.fillRect(0,0,w,h);
}

function drawBeach(w,h){
  ctx.fillStyle='#fde68a';
  ctx.fillRect(0,h*GROUND_Y,w,h);
  ctx.fillStyle='#0ea5e9';
  ctx.fillRect(0,h*WATER_Y,w,h);
}

function drawWave(w,h){
  if(!state.spriteLoaded) return;

  const {sw,sh}=spriteCellSize();
  const row = Math.floor(state.wavePhase*1.5) % 2; // alterna linhas 1 e 2
  let frame = Math.floor(state.wavePhase*5) % SPR_COLS;
  // descarta 1¬∫ frame da linha 1 (ruim)
  if(row === 0 && frame === 0) frame = 1;
  const sx = frame*sw;
  const sy = row*sh;

  // Converter coordenadas de mundo para tela
  const waveScreenX = (state.waveX - state.surferX) * w + PLAYER_X;

  // onda mais √† esquerda (atr√°s da prancha), com mais afastamento
  const dx = waveScreenX - sw*0.30; // mais longe do surfista (aumentado de 0.25 para 0.30)
  const dy = h*WATER_Y + Math.sin(state.wavePhase)*WAVE_AMPLITUDE - sh*0.57; // volta √† posi√ß√£o original

  ctx.drawImage(
    SPRITE,
    sx, sy, sw, sh,
    dx, dy,
    sw*1.1, sh*1.1 - 1  // remove 1 pixel da altura
  );
}

function drawRunner(w,h){
  if(!state.spriteLoaded) return;

  const {sw,sh}=spriteCellSize();
  let frame = Math.floor(state.runFrame) % SPR_COLS;
  // ignora o 1¬∫ frame da corrida (ruim)
  if(frame === 0) frame = 1;
  const sx = frame*sw + 3; // corta 3 pixels da esquerda
  const sy = 2*sh; // linha 3 (corrida)

  // Surfista sempre na posi√ß√£o fixa do jogador
  ctx.drawImage(
    SPRITE,
    sx, sy, sw - 3, sh, // remove 3 pixels de cada lado
    PLAYER_X, // posi√ß√£o fixa do jogador
    h*GROUND_Y - sh*0.55,
    sw*0.55, sh*0.55
  );
}

function drawSurfer(w,h){
  if(!state.spriteLoaded) return;

  const {sw,sh}=spriteCellSize();
  const frame = Math.floor(state.surfFrame) % SPR_COLS;
  const sx = frame*sw + 3; // corta 3 pixels da esquerda
  const sy = 3*sh; // linha 4 (subindo na prancha / surf)

  // Surfista sempre na posi√ß√£o fixa do jogador
  const dx = PLAYER_X - sw*0.15; // voltado ao normal
  const dy = h*SURFER_Y - sh*0.35 + state.surferY - (state.jumpY * h * 0.3); // altura do pulo

  ctx.save();
  
  // Aplicar inclina√ß√£o durante o pulo
  if(state.isJumping){
    ctx.translate(dx + sw*0.275, dy + sh*0.275); // centro do sprite
    ctx.rotate(state.jumpTilt); // inclina√ß√£o
    ctx.translate(-(dx + sw*0.275), -(dy + sh*0.275));
  }

  ctx.drawImage(
    SPRITE,
    sx, sy, sw - 3, sh, // remove 3 pixels de cada lado
    dx, dy,
    sw*0.55, sh*0.55
  );
  
  ctx.restore();
}

// ----- UPDATE -----
function update(dt){
  state.t+=dt;

  // spawn de obst√°culos durante o surf - sempre vindo, m√°ximo 2
  if(state.mode === 'surf' && state.t >= state.nextObstacleTime && state.obstacles.length < 2){
    const newObstacle = createObstacle();
    newObstacle.x = 3.0 + Math.random() * 2.0; // sempre entre 3.0 e 5.0 (fora da tela)
    state.obstacles.push(newObstacle);
    state.nextObstacleTime = state.t + 8; // 8 segundos entre spawns (sempre vindo)
  }

  // atualizar obst√°culos (movimento do mundo) - NUNCA REMOVER
  state.obstacles.forEach(obs => {
    obs.x -= dt * obs.speed; // move da direita para esquerda no mundo
    obs.phase += dt * 2; // movimento Y
    
    // Se sair da tela, volta para o come√ßo (sem reset)
    if(obs.x < -2.0){
      obs.x = 3.0 + Math.random() * 2.0; // volta para fora da tela
    }
  });

  if(state.mode==='run'){
    state.runFrame+=dt*12;
    if(state.runFrame >= 5) state.runFrame = 0; // reset de frame
    
    // Personagem se move no mundo, mas fica fixo na tela
    state.surferX = Math.min(0.35, state.surferX + dt*0.015);
    
    // Onda se aproxima no mundo (l√≥gica original)
    state.waveX+=dt*WAVE_SPEED;
    state.wavePhase+=dt*1.5;

    // Transi√ß√£o mais segura
    const waveDistance = Math.abs(state.waveX - state.surferX);
    if(waveDistance < 0.08){ // dist√¢ncia segura para transi√ß√£o
      state.mode='surf';
      state.onWave=true;
      state.surfFrame = 0;
      state.surfAnimDone = false;
      state.surfAltTime = state.t;
      console.log('Transi√ß√£o para surf mode - dist√¢ncia:', waveDistance.toFixed(3));
    }
  }

  if(state.mode === 'surf'){
    state.waveX+=dt*WAVE_SPEED;
    // REMOVIDO: reset da onda - agora continua infinitamente
    state.wavePhase+=dt*1.5;
    
    // F√≠sica do pulo com inclina√ß√£o
    if(state.isJumping){
      state.jumpVelocity += 2.0 * dt; // gravidade
      state.jumpY -= state.jumpVelocity * dt; // movimento vertical
      
      // Inclina√ß√£o durante o pulo (frente = negativo)
      if(state.jumpVelocity < 0){
        state.jumpTilt = Math.max(-0.3, state.jumpTilt - dt * 3); // inclina mais para frente
      } else {
        state.jumpTilt = Math.min(0, state.jumpTilt + dt * 3); // volta inclina√ß√£o para normal
      }
      
      // Verificar se aterrissou
      if(state.jumpY <= 0){
        state.jumpY = 0;
        state.jumpVelocity = 0;
        state.isJumping = false;
        state.jumpTilt = 0;
      }
    }
    
    // Onda empurra o surfista no mundo
    state.surferX = lerp(state.surferX, state.waveX + WAVE_PUSH_DIST + 0.15, dt * 2);
    state.surferY = Math.sin(state.wavePhase) * WAVE_AMPLITUDE;

    if(!state.surfAnimDone){
      state.surfFrame += dt * 3;
      
      // L√≥gica segura de frames
      if(state.surfFrame >= 1 && state.surfFrame < 3){
        state.surfFrame = 3; // pula para o frame 3
      }
      if(state.surfFrame >= 4){
        state.surfFrame = 4; // para no √∫ltimo quadro
        state.surfAnimDone = true;
        state.surfAltTime = state.t;
        console.log('Anima√ß√£o de surf conclu√≠da - frame final:', state.surfFrame);
      }
    } else {
      // intercala automaticamente entre frames 3 e 4 uma vez por segundo
      if(state.t - state.surfAltTime >= 1){
        state.surfFrame = state.surfFrame === 4 ? 3 : 4;
        state.surfAltTime = state.t;
      }
    }
  }
}

// ----- LOOP -----
let last=performance.now();
function loop(now){
  const dt=Math.min(0.032,(now-last)/1000); last=now;
  
  update(dt);

  const w=cvs.clientWidth, h=cvs.clientHeight;

  // fundo
  drawSky(w,h);
  drawBeach(w,h);

  // onda desenha em todos os modos (vem de tr√°s)
  drawWave(w,h);

  // obst√°culos (atr√°s do surfista)
  drawObstacles(w,h);

  // personagem na frente (sempre fixo na tela)
  if(state.mode==='run'){
    drawRunner(w,h);
  } else {
    drawSurfer(w,h);
  }

  // debug
  ctx.fillStyle='#fff';
  ctx.font='14px system-ui';
  ctx.fillText(state.mode.toUpperCase(),10,20);
  ctx.fillText(`runFrame=${Math.floor(state.runFrame)} surfFrame=${Math.floor(state.surfFrame)}`,10,40);
  ctx.fillText(`Obst√°culos: ${state.obstacles.length}`,10,60);
  ctx.fillText(`SurferX: ${state.surferX.toFixed(2)} WaveX: ${state.waveX.toFixed(2)}`,10,80);
  ctx.fillText(`DT: ${dt.toFixed(4)}`,10,100);
  if(state.mode==='surf'){
    ctx.fillText(state.onWave?'ON WAVE':'WAITING',10,120);
    ctx.fillText(`Jump: ${state.isJumping?'YES':'NO'} Y:${state.jumpY.toFixed(2)} Tilt:${state.jumpTilt.toFixed(2)}`,10,140);
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>