<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
<title>Orion & Yasminn — Corrida da Aventura</title>
<style>
  html,body{height:100%;margin:0;background:#000;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{display:grid;place-items:center;height:100%;gap:12px;padding:12px}
  .stack{position:relative;width:100%;max-width:900px}
  #game{width:100%;aspect-ratio:2/3;max-height:92vh;background:#000;border-radius:12px;box-shadow:0 8px 24px rgba(0,0,0,.35);display:block;touch-action:manipulation}
  .hud{display:flex;justify-content:space-between;align-items:center;width:100%;font-size:14px;color:#d1d5db;margin-top:8px}
  .pill{border:1px solid #ddd;padding:6px 10px;border-radius:999px;cursor:pointer;user-select:none;background:#111;color:#eee}
</style>

    <audio id="introSound" src="assets/intro.mp3" preload="auto"></audio>
    <audio id="bgMusic" src="assets/bg_music.mp3" preload="auto" loop></audio>
    <audio id="jumpSound" src="assets/jump.mp3" preload="auto"></audio>
    <audio id="hitSound" src="assets/hit.mp3" preload="auto"></audio>
    <audio id="pointSound" src="assets/point.mp3" preload="auto"></audio>
    <audio id="phaseSound" src="assets/phase_up.mp3" preload="auto"></audio>
    
</head>
<body>
<div class="wrap">
  <div class="stack">
    <canvas id="game"></canvas>
  </div>
  <div class="hud" id="hud" style="display:none">
    <div>Score: <span id="sc">0</span> | Record: <span id="hi">0</span></div>
    <div class="pill" id="reset">Zerar Recorde</div>
  </div>
</div>
<script>
(() => {
  const cvs = document.getElementById('game');
  const ctx = cvs.getContext('2d');
  ctx.imageSmoothingEnabled = false;

  function cardTint(id){
    if(id.startsWith('orion')) return 'rgba(56, 189, 248, 0.22)';
    if(id.startsWith('yasminn')) return 'rgba(244, 114, 182, 0.22)';
    return 'rgba(255,255,255,0.12)';
  }
  function cardStroke(id){
    if(id.startsWith('orion')) return 'rgba(56, 189, 248, 0.65)';
    if(id.startsWith('yasminn')) return 'rgba(244, 114, 182, 0.65)';
    return 'rgba(255,255,255,0.42)';
  }

  const menuClouds = Array.from({length:10}, () => ({
    x: Math.random()*900,
    y: Math.random()*520,
    r: 18 + Math.random()*48,
    layer: Math.random()<0.5 ? 0 : 1
  }));

  const introSound = document.getElementById('introSound');
  const bgMusic = document.getElementById('bgMusic');
  const jumpSound = document.getElementById('jumpSound');
  const hitSound = document.getElementById('hitSound');
  const pointSound = document.getElementById('pointSound');
  const phaseSound = document.getElementById('phaseSound');

  function safePlay(el){
    if(!el) return;
    try {
      const p = el.play();
      if(p && typeof p.catch === 'function') p.catch(()=>{});
    } catch (_) {}
  }

  let audioCtx = null;
  const audioNodes = new WeakMap();
  let adventure = null;
  let rainSfx = null;

  function ensureAudioCtx(){
    if(audioCtx) return audioCtx;
    const AC = window.AudioContext || window.webkitAudioContext;
    if(!AC) return null;
    audioCtx = new AC();
    return audioCtx;
  }

  function getStartButtonRect(){
    const w=cvs.clientWidth,h=cvs.clientHeight;
    const sidePad = Math.round(w*0.06);
    const btnW = Math.min(420, Math.max(220, w - sidePad*2));
    const btnH = Math.max(44, Math.min(74, Math.round(h*0.085)));
    const bx = Math.round((w-btnW)/2);
    const by = Math.round(Math.min(h - btnH - 10, h*0.90 - btnH/2));
    return {x:bx, y:by, w:btnW, h:btnH};
  }

  function drawBackdrop(w,h,now){
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,'#76D6FF');
    g.addColorStop(0.55,'#B5F0C7');
    g.addColorStop(1,'#F7D6A6');
    ctx.fillStyle=g;
    ctx.fillRect(0,0,w,h);

    // nuvens animadas
    for(const c of menuClouds){
      const sp = (c.layer===0 ? 0.12 : 0.22);
      c.x -= sp * (w/260) * 2.2;
      if(c.x + c.r*2 < 0){
        c.x = w + c.r*2;
        c.y = Math.random()*h*0.35;
        c.r = 18 + Math.random()*48;
        c.layer = Math.random()<0.5 ? 0 : 1;
      }
      const a = c.layer===0 ? 0.22 : 0.35;
      ctx.fillStyle = `rgba(255,255,255,${a})`;
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.r*0.55, 0, Math.PI*2);
      ctx.arc(c.x + c.r*0.55, c.y + c.r*0.1, c.r*0.65, 0, Math.PI*2);
      ctx.arc(c.x + c.r*1.1, c.y, c.r*0.5, 0, Math.PI*2);
      ctx.fill();
    }

    // vinheta leve
    const vg = ctx.createRadialGradient(w*0.5,h*0.35,Math.min(w,h)*0.1,w*0.5,h*0.35,Math.max(w,h)*0.75);
    vg.addColorStop(0,'rgba(0,0,0,0)');
    vg.addColorStop(1,'rgba(0,0,0,0.35)');
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,w,h);

    // destaque dos personagens (orion e yasminn)
    const s1 = SHEETS.sprite1?.spr?.ready && SHEETS.sprite1?.img?.complete;
    const s2 = SHEETS.sprite2?.spr?.ready && SHEETS.sprite2?.img?.complete;
    if(s1 || s2){
      const u = Math.max(6, Math.round(h/30));
      const size = Math.round(u*7.6);
      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.imageSmoothingEnabled = false;
      const f = runFrameAt(now);
      if(s2){
        const r = frameRectFor('yasminn', f);
        const img = SHEETS[r.sheetId].img;
        ctx.drawImage(img, r.sx, r.sy, r.sw, r.sh, Math.round(w*0.10), Math.round(h*0.72)-size, size, size);
      }
      if(s1){
        const r = frameRectFor('orion_dino', f);
        const img = SHEETS[r.sheetId].img;
        ctx.drawImage(img, r.sx, r.sy, r.sw, r.sh, Math.round(w*0.72), Math.round(h*0.72)-size, size, size);
      }
      ctx.restore();
    }
  }

  function nodeFor(el){
    const ctx = ensureAudioCtx();
    if(!ctx) return null;
    if(audioNodes.has(el)) return audioNodes.get(el);
    const src = ctx.createMediaElementSource(el);
    const gain = ctx.createGain();
    src.connect(gain);
    gain.connect(ctx.destination);
    const obj = {src, gain, out: gain, filters: []};
    audioNodes.set(el, obj);
    return obj;
  }

  function setChain(el, chain){
    const n = nodeFor(el);
    if(!n) return;
    try {
      n.out.disconnect();
    } catch(e) {}
    let out = n.gain;
    n.filters = [];
    for(const f of chain){
      out.connect(f);
      out = f;
      n.filters.push(f);
    }
    out.connect(audioCtx.destination);
    n.out = out;
  }

  function stopAdventureMusic(){
    if(!adventure) return;
    try { clearInterval(adventure.timer); } catch(e) {}
    try { adventure.master.gain.setTargetAtTime(0, audioCtx.currentTime, 0.05); } catch(e) {}
    adventure = null;
  }

  function startAdventureMusic(){
    const ctx = ensureAudioCtx();
    if(!ctx) return;
    if(adventure) return;

    // desligar a trilha atual (ruim) e usar trilha procedural
    try { bgMusic.pause(); } catch(e) {}
    bgMusic.playing = false;
    bgMusic.volume = 0;

    const master = ctx.createGain();
    master.gain.value = 0.0;

    const hp = ctx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 120;

    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -20;
    comp.ratio.value = 3.2;

    master.connect(hp);
    hp.connect(comp);
    comp.connect(ctx.destination);

    // fade in
    master.gain.setTargetAtTime(0.32, ctx.currentTime, 0.12);

    // sequências simples estilo "aventura infantil"
    const scale = [0, 2, 4, 5, 7, 9, 11]; // maior
    const bass = [0, 0, 5, 5, 3, 3, 4, 4];
    const melody = [0, 2, 4, 7, 4, 2, 5, 9, 7, 5, 4, 2, 0, 2, 4, 5];
    const rootMidi = 60; // C4
    let step = 0;

    const playNote = (midi, dur, type, gainVal, detune=0) => {
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      const f = ctx.createBiquadFilter();
      f.type = 'lowpass';
      f.frequency.value = type === 'square' ? 1600 : 2200;
      o.type = type;
      o.detune.value = detune;
      const freq = 440 * Math.pow(2, (midi - 69) / 12);
      o.frequency.value = freq;
      g.gain.value = 0;
      o.connect(f);
      f.connect(g);
      g.connect(master);
      const t0 = ctx.currentTime;
      // envelope suave
      g.gain.setValueAtTime(0, t0);
      g.gain.linearRampToValueAtTime(gainVal, t0 + 0.02);
      g.gain.exponentialRampToValueAtTime(Math.max(0.0001, gainVal * 0.35), t0 + dur * 0.85);
      g.gain.linearRampToValueAtTime(0, t0 + dur);
      o.start(t0);
      o.stop(t0 + dur + 0.01);
    };

    const bpm = 112;
    const beat = 60 / bpm;
    const tick = beat / 2; // colcheia
    const timer = setInterval(() => {
      if(!adventure) return;
      const s = step;
      const barPos = s % 16;
      const bassDegree = bass[Math.floor(s/2) % bass.length];
      const melDegree = melody[s % melody.length];

      // baixo (onda triangular)
      if(barPos % 2 === 0) {
        const m = rootMidi - 12 + scale[bassDegree % scale.length];
        playNote(m, tick * 1.6, 'triangle', 0.11);
      }

      // melodia (onda quadrada, bem leve)
      if(barPos % 2 === 1) {
        const m = rootMidi + scale[melDegree % scale.length];
        playNote(m, tick * 0.95, 'square', 0.06, -6);
      }

      // "sininho" sutil no início do compasso
      if(barPos === 0) {
        playNote(rootMidi + 12, tick * 0.55, 'sine', 0.05);
      }

      step = (step + 1) % 128;
    }, Math.round(tick * 1000));

    adventure = { master, timer };
  }

  function stopRainSfx(){
    if(!rainSfx) return;
    try { rainSfx.gain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.08); } catch(e) {}
    try { rainSfx.src.stop(); } catch(e) {}
    rainSfx = null;
  }

  function startRainSfx(intensity){
    const ctx = ensureAudioCtx();
    if(!ctx) return;
    if(rainSfx) {
      try { rainSfx.gain.gain.setTargetAtTime(0.04 + 0.10*(intensity||0), ctx.currentTime, 0.15); } catch(e) {}
      return;
    }
    const sr = ctx.sampleRate;
    const len = Math.floor(sr * 1.0);
    const buf = ctx.createBuffer(1, len, sr);
    const data = buf.getChannelData(0);
    for(let i=0;i<len;i++){
      // ruído branco
      data[i] = (Math.random()*2-1) * 0.35;
    }
    const src = ctx.createBufferSource();
    src.buffer = buf;
    src.loop = true;
    const bp = ctx.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = 1200;
    bp.Q.value = 0.8;
    const hp = ctx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 600;
    const gain = ctx.createGain();
    gain.gain.value = 0.0;
    src.connect(bp);
    bp.connect(hp);
    hp.connect(gain);
    gain.connect(ctx.destination);
    src.start();
    gain.gain.setTargetAtTime(0.02 + 0.06*(intensity||0), ctx.currentTime, 0.2);
    rainSfx = { src, gain };
  }

  function playThunder(strength){
    const ctx = ensureAudioCtx();
    if(!ctx) return;
    const t0 = ctx.currentTime;
    const dur = 1.2;

    const sr = ctx.sampleRate;
    const len = Math.floor(sr * dur);
    const buf = ctx.createBuffer(1, len, sr);
    const data = buf.getChannelData(0);
    for(let i=0;i<len;i++){
      const x = i/len;
      const env = Math.exp(-4*x);
      data[i] = (Math.random()*2-1) * env;
    }

    const src = ctx.createBufferSource();
    src.buffer = buf;
    const lp = ctx.createBiquadFilter();
    lp.type = 'lowpass';
    lp.frequency.value = 180;
    const gain = ctx.createGain();
    gain.gain.value = 0;
    src.connect(lp);
    lp.connect(gain);
    gain.connect(ctx.destination);
    const s = Math.max(0, Math.min(1, strength || 0));
    const g = 0.12 + 0.32*s;
    gain.gain.setValueAtTime(0.0001, t0);
    gain.gain.exponentialRampToValueAtTime(g, t0 + 0.05);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    src.start(t0);
    src.stop(t0 + dur + 0.05);
  }

  function playLightningCrack(strength){
    const ctx = ensureAudioCtx();
    if(!ctx) return;
    const t0 = ctx.currentTime;
    const s = Math.max(0, Math.min(1, strength || 0));
    const dur = 0.10;
    const sr = ctx.sampleRate;
    const len = Math.floor(sr * dur);
    const buf = ctx.createBuffer(1, len, sr);
    const data = buf.getChannelData(0);
    for(let i=0;i<len;i++){
      const x = i/len;
      const env = Math.exp(-18*x);
      data[i] = (Math.random()*2-1) * env;
    }
    const src = ctx.createBufferSource();
    src.buffer = buf;
    const hp = ctx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 1400;
    const bp = ctx.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = 2600;
    bp.Q.value = 0.9;
    const gain = ctx.createGain();
    gain.gain.value = 0;
    src.connect(hp);
    hp.connect(bp);
    bp.connect(gain);
    gain.connect(ctx.destination);
    const g = 0.06 + 0.14*s;
    gain.gain.setValueAtTime(0.0001, t0);
    gain.gain.exponentialRampToValueAtTime(g, t0 + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    src.start(t0);
    src.stop(t0 + dur + 0.02);
  }

  function softenJump(){
    jumpSound.volume = 0.18;
    jumpSound.playbackRate = 0.94;
    const ctx = ensureAudioCtx();
    if(!ctx) return;
    const lp = ctx.createBiquadFilter();
    lp.type = 'lowpass';
    lp.frequency.value = 1200;
    const g = ctx.createGain();
    g.gain.value = 0.70;
    setChain(jumpSound, [lp, g]);
  }

  function unlockAudio(){
    const ctx = ensureAudioCtx();
    if(ctx && ctx.state === 'suspended') {
      try { ctx.resume(); } catch(e) {}
    }
    startAdventureMusic();
    softenJump();
  }

  function fit(){
    const dpr=Math.max(1,Math.min(window.devicePixelRatio||1,2));
    const w=cvs.clientWidth,h=cvs.clientHeight;
    cvs.width=Math.round(w*dpr); cvs.height=Math.round(h*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  new ResizeObserver(fit).observe(cvs); fit();

  const bg = new Image(); bg.src = 'assets/menu_bg.jpg';
  const SHEETS = {
    sprite1: { raw: new Image(), img: null, spr: { cols:5, rows:4, w:0, h:0, ready:false } },
    sprite2: { raw: new Image(), img: null, spr: { cols:5, rows:4, w:0, h:0, ready:false } }
  };
  SHEETS.sprite1.raw.src = './sprite.png';
  SHEETS.sprite2.raw.src = './sprite2.png';

  function hasRealAlpha(img){
    const W = img.naturalWidth || img.width || 0;
    const H = img.naturalHeight || img.height || 0;
    if(!W || !H) return false;
    const c = document.createElement('canvas');
    c.width = W; c.height = H;
    const cctx = c.getContext('2d', { willReadFrequently:true });
    cctx.imageSmoothingEnabled = false;
    cctx.drawImage(img, 0, 0);
    const d = cctx.getImageData(0, 0, W, H).data;
    for(let i=3;i<d.length;i+=4){
      if(d[i] < 250) return true;
    }
    return false;
  }

  function applyTransparencyToSheet(img){
    const W = img.naturalWidth || img.width || 0;
    const H = img.naturalHeight || img.height || 0;
    const c = document.createElement('canvas');
    c.width = W; c.height = H;
    const cctx = c.getContext('2d', { willReadFrequently:true });
    cctx.imageSmoothingEnabled = false;
    cctx.drawImage(img, 0, 0);
    const id = cctx.getImageData(0, 0, W, H);
    const d = id.data;

    // Pegar 2 cores do padrão quadriculado a partir do canto superior esquerdo
    const bg1 = [d[0], d[1], d[2]];
    const i2 = (Math.min(24, W-1)) * 4;
    const bg2 = [d[i2], d[i2+1], d[i2+2]];
    const tol = 18;
    const close = (r,g,b, c) => (Math.abs(r-c[0])<=tol && Math.abs(g-c[1])<=tol && Math.abs(b-c[2])<=tol);

    for(let i=0;i<d.length;i+=4){
      const r=d[i], g=d[i+1], b=d[i+2];
      if(close(r,g,b,bg1) || close(r,g,b,bg2)){
        d[i+3] = 0;
      }
    }

    cctx.putImageData(id, 0, 0);
    return c;
  }

  function initSheet(sheetId){
    const s = SHEETS[sheetId];
    if(!s) return;
    const raw = s.raw;
    s.img = hasRealAlpha(raw) ? raw : applyTransparencyToSheet(raw);
    const W = s.img.naturalWidth || s.img.width;
    const H = s.img.naturalHeight || s.img.height;
    s.spr.w = Math.round(W / s.spr.cols);
    s.spr.h = Math.round(H / s.spr.rows);
    s.spr.ready = true;
  }
  SHEETS.sprite1.raw.onload = () => { initSheet('sprite1'); recomputeAllBounds(); };
  SHEETS.sprite2.raw.onload = () => { initSheet('sprite2'); recomputeAllBounds(); };

  const CHARACTERS = {
    orion: { name:'Orion', sheetId:'sprite1', row:0, trim:{l:1,t:0,r:1,b:0}, bounds:null },
    orion_dino: { name:'Orion (Dino)', sheetId:'sprite1', row:1, trim:{l:1,t:2,r:3,b:1}, bounds:null },
    orion_shark: { name:'Orion (Tubarão)', sheetId:'sprite1', row:2, trim:{l:6,t:0,r:10,b:0}, bounds:null },
    orion_bear: { name:'Orion (Urso)', sheetId:'sprite1', row:3, trim:{l:1,t:0,r:1,b:0}, bounds:null },

    yasminn: { name:'Yasminn', sheetId:'sprite2', row:0, trim:{l:1,t:0,r:1,b:0}, bounds:null },
    yasminn_dino: { name:'Yasminn (Dino)', sheetId:'sprite2', row:1, trim:{l:1,t:2,r:3,b:1}, bounds:null },
    yasminn_shark: { name:'Yasminn (Tubarão)', sheetId:'sprite2', row:2, trim:{l:6,t:0,r:10,b:0}, bounds:null },
    yasminn_bear: { name:'Yasminn (Urso)', sheetId:'sprite2', row:3, trim:{l:1,t:0,r:1,b:0}, bounds:null }
  };
  let currentCharacter = 'orion';

  const RUN_SEQ = [0,1,2,3,4];
  function runFrameAt(timeMs){
    const fps = 10;
    return RUN_SEQ[Math.floor((timeMs/1000) * fps) % RUN_SEQ.length];
  }

  function frameRect(sheetId, col, row){
    const s = SHEETS[sheetId];
    const img = s?.img;
    const spr = s?.spr;
    if(!img || !spr) return {sx:0,sy:0,sw:1,sh:1};
    const W = img.naturalWidth || img.width || 0;
    const H = img.naturalHeight || img.height || 0;
    const cw = W / spr.cols;
    const rh = H / spr.rows;
    const sx0 = Math.floor(col * cw);
    const sy0 = Math.floor(row * rh);
    const sx1 = Math.floor((col + 1) * cw);
    const sy1 = Math.floor((row + 1) * rh);
    let sx = sx0;
    let sy = sy0;
    let sw = Math.max(1, sx1 - sx0);
    let sh = Math.max(1, sy1 - sy0);
    return {sx, sy, sw, sh};
  }

  function frameRectFor(characterId, col){
    const ch = CHARACTERS[characterId];
    const row = ch?.row ?? 0;
    const sheetId = ch?.sheetId || 'sprite1';
    const t = ch?.trim || {l:0,t:0,r:0,b:0};
    const r = frameRect(sheetId, col, row);
    const sx = r.sx + (t.l||0);
    const sy = r.sy + (t.t||0);
    const sw = Math.max(1, r.sw - (t.l||0) - (t.r||0));
    const sh = Math.max(1, r.sh - (t.t||0) - (t.b||0));
    return {sx, sy, sw, sh, sheetId};
  }

  // ==== Bounds por alpha do 1º frame (com margens pequenas) ====
  function computeBoundsFor(characterId){
    const ch = CHARACTERS[characterId];
    if(!ch) return {ox:.12,oy:.10,ow:.7,oh:.85};
    const s = SHEETS[ch.sheetId];
    if(!s?.spr?.ready || !s?.img) return {ox:.12,oy:.10,ow:.7,oh:.85};
    const SPR = s.spr;
    const off=document.createElement('canvas'); off.width=SPR.w; off.height=SPR.h;
    const octx=off.getContext('2d',{willReadFrequently:true}); octx.imageSmoothingEnabled=false;
    const r = frameRectFor(characterId, 0);
    octx.drawImage(s.img,r.sx,r.sy,r.sw,r.sh,0,0,SPR.w,SPR.h);
    const d=octx.getImageData(0,0,SPR.w,SPR.h).data;
    let minX=SPR.w,minY=SPR.h,maxX=0,maxY=0,found=false;
    for(let y=0;y<SPR.h;y++){ for(let x=0;x<SPR.w;x++){ if(d[(y*SPR.w+x)*4+3]>10){ if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; found=true; } } }
    if(!found) return {ox:.12,oy:.10,ow:.7,oh:.85};
    let ox=minX/SPR.w, oy=minY/SPR.h, ow=(maxX-minX+1)/SPR.w, oh=(maxY-minY+1)/SPR.h;
    const shrinkX=0.08, shrinkY=0.08; ox+=shrinkX; ow-=shrinkX*1.6; oy+=shrinkY; oh-=shrinkY*1.2;
    return {ox,oy,ow,oh};
  }

  function recomputeAllBounds(){
    for(const id of Object.keys(CHARACTERS)){
      CHARACTERS[id].bounds = computeBoundsFor(id);
    }
  }

  const cactusImages = [];
  for (let i = 1; i <= 14; i++) {
    const img = new Image();
    img.src = `assets/${i}.png`;
    cactusImages.push(img);
  }

  const phases = [
    { name:'Manhã', bg:['#87CEEB','#E8F7FF'], ground:'#D8B07B', speedMul:1.0, spawnMul:1.0 },
    { name:'Tarde', bg:['#FFE29F','#FFA99F'], ground:'#D4A574', speedMul:1.15, spawnMul:0.9 },
    { name:'Pôr do sol', bg:['#FF6A88','#FF99AC'], ground:'#C98B5A', speedMul:1.32, spawnMul:0.8 },
    { name:'Noite', bg:['#0F2027','#203A43'], ground:'#8B6B4B', speedMul:1.55, spawnMul:0.72 },
    { name:'Tempestade', bg:['#232526','#414345'], ground:'#7A5C44', speedMul:1.8, spawnMul:0.65 }
  ];

  // ==== Estados ====
  const state = {
    mode:'characterSelect',
    score:0,
    hi:Number(localStorage.getItem('dino_hi')||0),
    phase:0,
    phaseOverlay:0,
    nextPhaseAt:10,
    lastPointAt:0,
    weather: null,
    lightning: 0,
    nextLightningAt: 0,
    upgradeAt: 10,
    upgradeOptions: null,
    startBtn: null,
    lives: 3,
    maxLives: 3,
    power: {
      invulnUntil: 0,
      jumpUntil: 0,
      slowUntil: 0,
      cdInvuln: 0,
      cdJump: 0,
      cdSlow: 0,
      cdLife: 0
    }
  };
  document.getElementById('hi').textContent = '0';
  const hud = document.getElementById('hud');

  const bestByCharacter = JSON.parse(localStorage.getItem('dino_best_by_character') || '{}');
  let bestCharacterId = localStorage.getItem('dino_best_character_id') || '';
  let bestCharacterScore = Number(localStorage.getItem('dino_best_character_score') || '0');
  document.getElementById('hi').textContent = String(bestCharacterScore || 0);

  const UNIT = () => Math.max(6, Math.round(cvs.clientHeight/30));
  const GY = () => Math.round(cvs.clientHeight*0.80);
  let PLAYER_X = Math.round(cvs.clientWidth*0.16);
  new ResizeObserver(()=>{ PLAYER_X = Math.round(cvs.clientWidth*0.16); }).observe(cvs);

  const world = {
    gravity:()=>28*UNIT(),
    jump:()=>20*UNIT(),
    baseSpeed:()=>11*UNIT(),
    speed:0,
    obstacles:[],
    dist:0,
    clouds:[]
  };
  const player = { y:0, vy:0, onGround:true, t:0, f:0, scale:1.2 };

  function drawHearts(x, y, size, spacing){
    ctx.save();
    ctx.textAlign='left'; ctx.textBaseline='middle';
    for(let i=0;i<state.maxLives;i++){
      const px = x + i*spacing;
      const filled = i < state.lives;
      ctx.fillStyle = filled ? '#ef4444' : '#374151';
      ctx.font = `${size}px sans-serif`;
      ctx.fillText('♥', px, y);
    }
    ctx.restore();
  }

  function drawGameHUD(w, h){
    ctx.save();
    const bestName = bestCharacterId && CHARACTERS[bestCharacterId] ? CHARACTERS[bestCharacterId].name : '';
    const recFull = bestName ? `${bestCharacterScore} (${bestName})` : `${bestCharacterScore || 0}`;
    const recShort = `${bestCharacterScore || 0}`;
    let text = `SCORE ${state.score}   •   RECORD ${recFull}`;
    const boxH = Math.max(34, Math.round(h*0.055));
    const heartSize = Math.round(boxH*0.55);
    const heartSpacing = Math.round(heartSize*1.1);
    const heartsW = state.maxLives*heartSpacing;
    const padX = Math.round(boxH*0.55);
    const maxBoxW = w - 16;

    let fontSize = Math.round(boxH*0.40);
    const measure = () => {
      ctx.font = `800 ${fontSize}px system-ui`;
      return ctx.measureText(text).width;
    };
    let tw = measure();
    while(fontSize > 9 && (tw + padX*3 + heartsW) > maxBoxW){
      fontSize = Math.round(fontSize*0.92);
      tw = measure();
    }
    if((tw + padX*3 + heartsW) > maxBoxW){
      text = `SCORE ${state.score}   •   RECORD ${recShort}`;
      fontSize = Math.max(9, Math.round(boxH*0.36));
      tw = measure();
      while(fontSize > 8 && (tw + padX*3 + heartsW) > maxBoxW){
        fontSize = Math.round(fontSize*0.92);
        tw = measure();
      }
    }

    const boxW = Math.min(maxBoxW, Math.round(tw + padX*3 + heartsW));
    const x = Math.round((w - boxW)/2);
    const y = Math.round(h*0.02);
    // sombra
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(x, y + 3, boxW, boxH);
    // pill
    ctx.fillStyle = 'rgba(15, 23, 42, 0.82)';
    ctx.fillRect(x, y, boxW, boxH);
    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
    ctx.lineWidth = 2;
    ctx.strokeRect(x+1, y+1, boxW-2, boxH-2);
    // texto
    ctx.fillStyle = '#fff';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(text, x + boxW/2 - heartsW*0.52, y + boxH/2);
    // corações
    drawHearts(x + boxW - padX - heartsW, y + boxH/2, heartSize, heartSpacing);
    ctx.restore();
  }

  function drawRainLayer(w, h, now, intensity, isStorm, yMaxMul, alphaBoost, widthBoost, lenBoost){
    const rain = Math.max(0, Math.min(1, intensity || 0));
    const baseDrops = isStorm ? 380 : 280;
    const drops = Math.floor(baseDrops * rain);
    const yMax = Math.max(1, h * (yMaxMul || 1));
    ctx.save();
    const a0 = isStorm ? (0.8 + rain*0.2) : (0.7 + rain*0.2);
    const a = Math.min(1, a0 * (alphaBoost || 1));
    ctx.strokeStyle = isStorm
      ? `rgba(100,140,200,${a})`
      : `rgba(120,160,220,${a})`;
    ctx.lineWidth = (isStorm ? 4 : 3) * (widthBoost || 1);
    for(let i=0;i<drops;i++){
      const x = (Math.random()*w + now*0.3) % w;
      const y = (Math.random()*yMax + now*0.8) % yMax;
      const len = (isStorm ? (15 + rain*20) : (12 + rain*18)) * (lenBoost || 1);
      const angle = isStorm ? -2.5 : -2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + angle, y + len);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawGround(w, h, phase, weather, scrollX){
    const groundY = GY() + UNIT()*0.5;
    const groundH = h - groundY;
    // Base do chão (cor da fase)
    ctx.fillStyle = phase.ground;
    ctx.fillRect(0, groundY, w, groundH);
    const isDay = weather && weather.type === 'day';
    const isNight = weather && weather.type === 'night';
    const isRain = weather && (weather.type === 'rain');
    const isStorm = weather && (weather.type === 'storm');
    const rainAmt = weather ? (weather.rain || 0) : 0;

    const u = UNIT();
    const sx = (scrollX || 0);
    const seed = 1337 + Math.floor((sx || 0) * 0.01);
    const hash01 = (n) => {
      const x = Math.sin(n * 999.123 + seed * 0.017) * 43758.5453;
      return x - Math.floor(x);
    };

    const topH = Math.max(10, Math.round(u*1.15));
    const patternStep = Math.max(16, Math.round(u*2.8));
    const off = ((sx*0.8) % patternStep);

    // Grama (dia): faixa verde estática com "dentinhos" retangulares
    if(isDay && !(isRain || isStorm)){
      ctx.fillStyle = '#2fae4f';
      ctx.fillRect(0, groundY, w, topH);
      ctx.fillStyle = 'rgba(10,70,25,0.28)';
      for(let x=-patternStep; x<w+patternStep; x+=patternStep){
        const k = Math.floor((x + sx*0.2)/patternStep);
        const h1 = Math.round(u*(0.35 + hash01(k*3.1)*0.65));
        ctx.fillRect(x - off + Math.round(patternStep*0.15), groundY + topH - h1, Math.round(patternStep*0.12), h1);
        ctx.fillRect(x - off + Math.round(patternStep*0.42), groundY + topH - Math.round(h1*0.75), Math.round(patternStep*0.10), Math.round(h1*0.75));
        ctx.fillRect(x - off + Math.round(patternStep*0.70), groundY + topH - Math.round(h1*0.55), Math.round(patternStep*0.08), Math.round(h1*0.55));
      }
    }

    // Lama (chuva/temporal): marrom escuro com faixas horizontais
    if((isRain || isStorm) && rainAmt > 0){
      ctx.fillStyle = '#5a3f2b';
      ctx.fillRect(0, groundY, w, groundH);
      ctx.fillStyle = 'rgba(0,0,0,0.16)';
      for(let y=groundY + Math.round(u*1.0); y<groundY + groundH; y+=Math.max(10, Math.round(u*1.6))){
        ctx.fillRect(0, y, w, Math.max(2, Math.round(u*0.22)));
      }
      // poças retangulares (estáticas, sem bolinhas)
      const puddleStep = Math.max(46, Math.round(u*7.2));
      const puddleOff = ((sx*0.55) % puddleStep);
      for(let x=-puddleStep*2; x<w+puddleStep*2; x+=puddleStep){
        const k = Math.floor((x + sx*0.3)/puddleStep);
        if(hash01(k*5.7) < 0.55) continue;
        const px = x - puddleOff + puddleStep*(0.18 + 0.55*hash01(k*2.3));
        const py = groundY + topH + (groundH*0.35 + groundH*0.35*hash01(k*9.1));
        const pw = puddleStep*(0.55 + 0.35*hash01(k*4.9));
        const ph = Math.max(7, Math.round(u*(0.75 + 0.9*hash01(k*6.1))));
        ctx.fillStyle = 'rgba(120,160,210,0.38)';
        ctx.fillRect(px, py, pw, ph);
        ctx.fillStyle = 'rgba(255,255,255,0.14)';
        ctx.fillRect(px + pw*0.12, py + ph*0.20, pw*0.28, Math.max(2, ph*0.25));
      }
    }

    // Pedra/estrada (noite/tempestade): cinza com blocos retangulares
    if((isNight || phase?.name === 'Noite' || phase?.name === 'Tempestade') && !(isRain || isStorm)){
      ctx.fillStyle = '#6f6f6f';
      ctx.fillRect(0, groundY, w, groundH);
      ctx.fillStyle = 'rgba(0,0,0,0.12)';
      for(let x=-patternStep; x<w+patternStep; x+=patternStep){
        const k = Math.floor((x + sx*0.25)/patternStep);
        const bw = Math.round(patternStep*(0.35 + 0.55*hash01(k*2.7)));
        const bh = Math.round(u*(0.55 + 0.85*hash01(k*4.1)));
        const bx = x - off + Math.round(patternStep*0.20);
        const by = groundY + topH + Math.round(groundH*0.18 + groundH*0.55*hash01(k*6.9));
        ctx.fillRect(bx, by, bw, bh);
      }
      // faixa de estrada
      const roadH = Math.max(16, Math.round(u*2.2));
      const roadY = groundY + topH + Math.max(10, Math.round(groundH*0.42));
      ctx.fillStyle = 'rgba(15, 23, 42, 0.16)';
      ctx.fillRect(0, roadY, w, roadH);
      const dashW = Math.max(18, Math.round(u*2.8));
      const dashGap = Math.max(14, Math.round(u*2.2));
      const cycle = dashW + dashGap;
      const dashOff = ((sx*0.75) % cycle);
      ctx.fillStyle = 'rgba(255,255,255,0.16)';
      for(let x=-cycle; x<w+cycle; x+=cycle){
        ctx.fillRect(x - dashOff, roadY + roadH*0.45, dashW, Math.max(2, Math.round(u*0.22)));
      }
    }

    // Detalhe de linha superior (sombra)
    ctx.fillStyle='rgba(0,0,0,.12)';
    ctx.fillRect(0, groundY, w, 3);
  }

  function drawSun(w, h, weather){
    if(weather && (weather.type === 'day' || weather.type === 'fog')){
      const sunX = w*0.85;
      const sunY = h*0.15;
      const sunR = Math.min(56, Math.min(w,h)*0.12);
      ctx.save();
      ctx.globalAlpha = weather.type === 'fog' ? 0.3 : 0.9;
      ctx.fillStyle = '#ffd700';
      ctx.beginPath(); ctx.arc(sunX, sunY, sunR, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#ffed4e';
      ctx.beginPath(); ctx.arc(sunX, sunY, sunR*1.4, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }

  function drawBirds(w, h, weather, now){
    if(weather && weather.type !== 'storm' && Math.random() < 0.3){
      ctx.save();
      ctx.fillStyle = weather.type === 'night' ? '#444' : '#222';
      for(let i=0; i<3; i++){
        const t = (now/1000 + i*2) % 8;
        const x = ((t/8)*w*1.4 - w*0.2) % w;
        const y = h*0.25 + Math.sin(t)*h*0.06;
        const size = 32 + Math.sin(t*2)*12;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - size, y + size*0.7);
        ctx.lineTo(x + size, y + size*0.7);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
    }
  }

  function pickWeather(){
    const r = Math.random();
    if(r < 0.25) return { type:'day', tint:'rgba(0,0,0,0)', rain:0, fog:0 };
    if(r < 0.45) return { type:'night', tint:'rgba(10,20,45,0.35)', rain:0, fog:0.05 };
    if(r < 0.55) return { type:'fog', tint:'rgba(220,230,255,0.16)', rain:0, fog:0.22 };
    if(r < 0.80) return { type:'rain', tint:'rgba(30,40,70,0.20)', rain:0.55, fog:0.10 };
    return { type:'storm', tint:'rgba(10,10,20,0.35)', rain:0.85, fog:0.14 };
  }

  
    function startGame(){
      try { bgMusic.currentTime = 0; } catch(_) {}
      safePlay(bgMusic);
      bgMusic.playing = true;
      introSound.pause(); introSound.playing = false;
    
    // limpar tela para evitar resquício do menu
    ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,cvs.width,cvs.height); ctx.restore();
    state.mode='play'; hud.style.display='flex';
    state.score = 0;
    document.getElementById('sc').textContent = '0';
    state.phase = 0;
    state.phaseOverlay = 4.2;
    state.nextPhaseAt = 10;
    state.upgradeAt = 10;
    state.upgradeOptions = null;
    state.power.invulnUntil = 0;
    state.power.jumpUntil = 0;
    state.power.slowUntil = 0;
    state.power.cdInvuln = 0;
    state.power.cdJump = 0;
    state.power.cdSlow = 0;
    state.power.cdLife = 0;
    state.lives = state.maxLives;
    state.weather = pickWeather();
    state.lightning = 0;
    state.nextLightningAt = performance.now() + 2500 + Math.random()*2500;
    world.speed=world.baseSpeed();
    world.obstacles.length=0;
    world.dist=0;
    world.clouds = Array.from({length:18}, (_,i) => ({
      x: Math.random()*cvs.clientWidth,
      y: i < 12 ? (Math.random()*cvs.clientHeight*0.32) : (cvs.clientHeight*0.18 + Math.random()*cvs.clientHeight*0.38),
      r: (i < 12 ? (18 + Math.random()*42) : (24 + Math.random()*58)),
      layer: Math.random()<0.5 ? 0 : 1,
      band: i < 12 ? 'high' : 'low'
    }));
    player.y = GY() - 3.4*UNIT(); player.vy=0; player.onGround=true; player.t=0; player.f=0;

    // sfx de clima
    if(state.weather && state.weather.rain > 0) startRainSfx(state.weather.rain);
    else stopRainSfx();
  }

  
    function drawMenu(){
      if (!introSound.playing) {
        safePlay(introSound);
        introSound.playing = true;
      }
    
    const w=cvs.clientWidth,h=cvs.clientHeight;
    drawBackdrop(w,h,performance.now());
    // (removido) não desenhar sprite no menu
    {
    }
    // botão JOGAR
    const sidePad = Math.round(w*0.06);
    const btnW = Math.min(340, Math.max(220, w - sidePad*2));
    const btnH = Math.max(44, Math.min(70, Math.round(h*0.085)));
    const bx = Math.round((w-btnW)/2);
    const by = Math.round(Math.min(h - btnH - 12, h*0.80));
    ctx.fillStyle = '#e8d3ac'; ctx.fillRect(bx,by,btnW,btnH);
    ctx.fillStyle = '#6b4b26'; ctx.fillRect(bx,by+btnH-6,btnW,6);
    ctx.fillStyle = '#5a4634';
    ctx.font = `bold ${Math.round(btnH*0.48)}px system-ui`;
    ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText('JOGAR', bx+btnW/2, by+btnH*0.55);
  }

  function drawCharacterSelect(now){
    const w=cvs.clientWidth,h=cvs.clientHeight;
    drawBackdrop(w,h,now || performance.now());
    ctx.fillStyle='rgba(0,0,0,0.55)';
    ctx.fillRect(0,0,w,h);

    ctx.fillStyle='#e8d3ac';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    const title = 'ORION & YASMINN — CORRIDA DA AVENTURA';
    let titleSize = Math.round(h*0.055);
    ctx.font = `bold ${titleSize}px system-ui`;
    while(titleSize > 18 && ctx.measureText(title).width > w*0.92){
      titleSize = Math.round(titleSize * 0.92);
      ctx.font = `bold ${titleSize}px system-ui`;
    }
    let titleTwoLines = false;
    let titleBottomY = h*0.10;
    if(ctx.measureText(title).width <= w*0.92){
      const ty = h*0.10;
      ctx.fillText(title, w/2, ty);
      titleBottomY = ty + titleSize*0.75;
    } else {
      titleTwoLines = true;
      // fallback mobile: duas linhas para não vazar
      const t1 = 'ORION & YASMINN';
      const t2 = 'CORRIDA DA AVENTURA';
      let s1 = Math.round(h*0.055);
      ctx.font = `bold ${s1}px system-ui`;
      while(s1 > 16 && (ctx.measureText(t1).width > w*0.92 || ctx.measureText(t2).width > w*0.92)){
        s1 = Math.round(s1 * 0.92);
        ctx.font = `bold ${s1}px system-ui`;
      }
      const lh = Math.round(s1*1.05);
      const tTop = h*0.085;
      ctx.fillText(t1, w/2, tTop);
      ctx.fillText(t2, w/2, tTop + lh);
      titleBottomY = tTop + lh + s1*0.75;
    }
    ctx.fillStyle='rgba(255,255,255,0.88)';
    const subtitle = 'Escolha sua fantasia e corra!';
    let subSize = Math.round(h*0.032);
    ctx.font = `${subSize}px system-ui`;
    while(subSize > 12 && ctx.measureText(subtitle).width > w*0.90){
      subSize = Math.round(subSize * 0.92);
      ctx.font = `${subSize}px system-ui`;
    }
    const subtitleY = Math.round(Math.min(h*0.24, titleBottomY + Math.max(10, Math.round(h*0.02))));
    if(ctx.measureText(subtitle).width <= w*0.90){
      ctx.fillText(subtitle, w/2, subtitleY);
    } else {
      const subFont = `${subSize}px system-ui`;
      wrapTextCentered(subtitle, w/2, subtitleY, w*0.90, Math.round(subSize*1.15), subFont);
    }

    // botão COMEÇAR (usado também para limitar o grid no mobile)
    const br = getStartButtonRect();

    const cards = Object.entries(CHARACTERS);
    const cols = w >= 860 ? 4 : (w >= 520 ? 3 : 2);
    const rows = Math.ceil(cards.length / cols);
    const gapX = Math.round(w*0.03);
    const gapY = Math.round(h*0.028);
    const startY = Math.max(Math.round(h*0.20), subtitleY + Math.round(h*0.055));
    const availW = w - gapX*(cols+1);
    const bottomPad = Math.max(10, Math.round(h*0.02));
    const bottomLimit = Math.max(startY + 60, br.y - bottomPad);
    const availH = Math.max(0, bottomLimit - startY);
    const cardW = Math.floor(availW / cols);
    const cardH = Math.floor(Math.min(cardW*0.82, (availH - gapY*(rows-1)) / rows));

    const t = now || performance.now();
    const previewFrame = runFrameAt(t);

    for(let i=0;i<cards.length;i++){
      const [id, ch] = cards[i];
      const cx = gapX + (i%cols)*(cardW+gapX);
      const cy = startY + Math.floor(i/cols)*(cardH+gapY);

      ctx.fillStyle = cardTint(id);
      ctx.fillRect(cx, cy, cardW, cardH);
      ctx.lineWidth = (id===currentCharacter) ? 3 : 2;
      ctx.strokeStyle = (id===currentCharacter) ? '#e8d3ac' : cardStroke(id);
      ctx.strokeRect(cx, cy, cardW, cardH);

      // preview animado
      {
        const pr = frameRectFor(id, previewFrame);
        const s = SHEETS[pr.sheetId];
        if(s?.spr?.ready && s?.img?.complete){
          const pw = Math.round(cardW*0.38);
          const ph = Math.round(pw*(s.spr.h/s.spr.w));
          const px = cx + Math.round(cardW*0.10);
          const py = cy + Math.round(cardH*0.18);
          ctx.save();
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(s.img, pr.sx, pr.sy, pr.sw, pr.sh, px, py, pw, ph);
          ctx.restore();
        }
      }

      ctx.fillStyle='#fff';
      ctx.textAlign='left';
      const nameX = cx + Math.round(cardW*0.52);
      const nameY = cy + Math.round(cardH*0.40);
      const maxW = cx + cardW - nameX - Math.round(cardW*0.04);

      let nameSize = Math.round(cardH*0.105);
      let nm = ch.name;
      ctx.font = `bold ${nameSize}px system-ui`;
      while(nameSize > 11 && ctx.measureText(nm).width > maxW){
        nameSize = Math.round(nameSize*0.92);
        ctx.font = `bold ${nameSize}px system-ui`;
      }
      while(nm.length > 0 && ctx.measureText(nm).width > maxW) nm = nm.slice(0, -1);
      if(nm !== ch.name) nm = nm.slice(0, Math.max(0, nm.length-1)) + '…';
      ctx.fillText(nm, nameX, nameY);

      ctx.fillStyle='rgba(255,255,255,0.8)';
      let hint = 'Toque p/ escolher';
      let hintSize = Math.round(cardH*0.08);
      ctx.font = `${hintSize}px system-ui`;
      while(hintSize > 10 && ctx.measureText(hint).width > maxW){
        hintSize = Math.round(hintSize*0.92);
        ctx.font = `${hintSize}px system-ui`;
      }
      if(ctx.measureText(hint).width > maxW) hint = 'Toque';
      ctx.fillText(hint, nameX, cy + Math.round(cardH*0.58));

      const best = Number(bestByCharacter[id] || 0);
      ctx.fillStyle='rgba(255,255,255,0.90)';
      let bestLine = `Melhor: ${best}`;
      let bestSize = Math.round(cardH*0.078);
      ctx.font = `${bestSize}px system-ui`;
      while(bestSize > 10 && ctx.measureText(bestLine).width > maxW){
        bestSize = Math.round(bestSize*0.92);
        ctx.font = `${bestSize}px system-ui`;
      }
      if(ctx.measureText(bestLine).width > maxW) bestLine = `${best}`;
      ctx.fillText(bestLine, nameX, cy + Math.round(cardH*0.76));
    }

    ctx.textAlign='center';
    ctx.fillStyle='rgba(255,255,255,0.86)';
    ctx.font=`${Math.round(h*0.03)}px system-ui`;
    const bestName = bestCharacterId && CHARACTERS[bestCharacterId] ? CHARACTERS[bestCharacterId].name : '';
    const msg = bestName ? `Record: ${bestCharacterScore} (${bestName})` : `Record: ${bestCharacterScore || 0}`;
    const recordY = Math.min(br.y - Math.round(br.h*0.55), bottomLimit - Math.round(h*0.02));
    ctx.fillText(msg, w/2, recordY);

    // botão COMEÇAR
    ctx.fillStyle = 'rgba(232,211,172,0.95)';
    ctx.fillRect(br.x, br.y, br.w, br.h);
    ctx.fillStyle = 'rgba(107,75,38,1)';
    ctx.fillRect(br.x, br.y + br.h - 6, br.w, 6);
    ctx.strokeStyle = 'rgba(0,0,0,0.20)';
    ctx.lineWidth = 2;
    ctx.strokeRect(br.x+1, br.y+1, br.w-2, br.h-2);
    ctx.fillStyle = '#3b2d22';
    ctx.font = `900 ${Math.round(br.h*0.42)}px system-ui`;
    ctx.textBaseline='middle';
    ctx.fillText('COMEÇAR A AVENTURA', w/2, br.y + br.h*0.52);
    // (removido) texto extra para não poluir/atrapalhar no mobile
  }

  
    function spawn(){
      const u=UNIT();
      const s=1+Math.floor(Math.random()*3);
      const w=(0.9+0.5*s)*u*2, h=(1.2+0.5*s)*u*1;
      const gap=u*(20+Math.random()*16);
      const cactusIndex = Math.floor(Math.random()*14); // de 0 a 13
      world.obstacles.push({x:cvs.clientWidth+gap,y:GY()-h+UNIT()*0.8,w,h,cactusIndex});
    }
    

  function pickCharacterAt(x,y){
    const w=cvs.clientWidth,h=cvs.clientHeight;
    const br = getStartButtonRect();

    // Reproduz o cálculo do subtitleY/startY para o hit-test casar com o layout
    ctx.textAlign='center'; ctx.textBaseline='middle';
    const title = 'ORION & YASMINN — CORRIDA DA AVENTURA';
    let titleSize = Math.round(h*0.055);
    ctx.font = `bold ${titleSize}px system-ui`;
    while(titleSize > 18 && ctx.measureText(title).width > w*0.92){
      titleSize = Math.round(titleSize * 0.92);
      ctx.font = `bold ${titleSize}px system-ui`;
    }
    let titleBottomY = h*0.10 + titleSize*0.75;
    if(ctx.measureText(title).width > w*0.92){
      const t1 = 'ORION & YASMINN';
      const t2 = 'CORRIDA DA AVENTURA';
      let s1 = Math.round(h*0.055);
      ctx.font = `bold ${s1}px system-ui`;
      while(s1 > 16 && (ctx.measureText(t1).width > w*0.92 || ctx.measureText(t2).width > w*0.92)){
        s1 = Math.round(s1 * 0.92);
        ctx.font = `bold ${s1}px system-ui`;
      }
      const lh = Math.round(s1*1.05);
      const tTop = h*0.085;
      titleBottomY = tTop + lh + s1*0.75;
    }
    const subtitleY = Math.round(Math.min(h*0.24, titleBottomY + Math.max(10, Math.round(h*0.02))));

    const cards = Object.entries(CHARACTERS);
    const cols = w >= 860 ? 4 : (w >= 520 ? 3 : 2);
    const rows = Math.ceil(cards.length / cols);
    const gapX = Math.round(w*0.03);
    const gapY = Math.round(h*0.028);
    const startY = Math.max(Math.round(h*0.20), subtitleY + Math.round(h*0.055));
    const availW = w - gapX*(cols+1);
    const bottomPad = Math.max(10, Math.round(h*0.02));
    const bottomLimit = Math.max(startY + 60, br.y - bottomPad);
    const availH = Math.max(0, bottomLimit - startY);
    const cardW = Math.floor(availW / cols);
    const cardH = Math.floor(Math.min(cardW*0.82, (availH - gapY*(rows-1)) / rows));
    for(let i=0;i<cards.length;i++){
      const [id] = cards[i];
      const cx = gapX + (i%cols)*(cardW+gapX);
      const cy = startY + Math.floor(i/cols)*(cardH+gapY);
      if(x>=cx && x<=cx+cardW && y>=cy && y<=cy+cardH){
        currentCharacter = id;
        if(!CHARACTERS[id].bounds) CHARACTERS[id].bounds = computeBoundsFor(id);
        return true;
      }
    }
    return false;
  }

  function playUpgradeSfx(id){
    const ctx = ensureAudioCtx();
    if(!ctx) return;
    const t0 = ctx.currentTime;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    const lp = ctx.createBiquadFilter();
    lp.type = 'lowpass';
    lp.frequency.value = 2000;
    o.connect(lp);
    lp.connect(g);
    g.connect(ctx.destination);
    g.gain.value = 0;

    if(id==='invuln'){
      o.type = 'sine';
      o.frequency.setValueAtTime(660, t0);
      o.frequency.exponentialRampToValueAtTime(990, t0 + 0.18);
      o.frequency.exponentialRampToValueAtTime(550, t0 + 0.42);
    }
    if(id==='jump'){
      o.type = 'triangle';
      o.frequency.setValueAtTime(520, t0);
      o.frequency.exponentialRampToValueAtTime(1040, t0 + 0.22);
    }
    if(id==='slow'){
      o.type = 'square';
      lp.frequency.value = 1200;
      o.frequency.setValueAtTime(220, t0);
      o.frequency.exponentialRampToValueAtTime(165, t0 + 0.35);
    }
    if(id==='life'){
      o.type = 'sine';
      o.frequency.setValueAtTime(440, t0);
      o.frequency.exponentialRampToValueAtTime(880, t0 + 0.12);
      o.frequency.exponentialRampToValueAtTime(660, t0 + 0.28);
    }

    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(0.08, t0 + 0.03);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.55);
    o.start(t0);
    o.stop(t0 + 0.6);
  }

  function upgradeRects(){
    const w=cvs.clientWidth,h=cvs.clientHeight;
    const opts = state.upgradeOptions || [];
    const cols = w >= 820 ? 3 : 1;
    const cardW = cols === 3 ? Math.round(w*0.28) : Math.round(w*0.86);
    let cardH = Math.round(Math.max(86, cardW*0.52));
    let gap = Math.round(cardH*0.18);
    const startX = cols === 3 ? Math.round((w - (cardW*3 + gap*2))/2) : Math.round((w-cardW)/2);
    const startY = Math.round(h*0.26);
    if(cols === 1 && opts.length){
      const bottomPad = Math.round(h*0.06);
      const availH = Math.max(0, h - startY - bottomPad);
      gap = Math.min(gap, Math.round(h*0.03));
      const maxCardH = Math.floor((availH - gap*(opts.length-1)) / opts.length);
      if(maxCardH > 0) cardH = Math.max(74, Math.min(cardH, maxCardH));
      gap = Math.min(gap, Math.max(10, Math.round((availH - cardH*opts.length) / Math.max(1, opts.length-1))));
    }
    const rects = [];
    for(let i=0;i<opts.length;i++){
      const cx = cols === 3 ? (startX + i*(cardW+gap)) : startX;
      const cy = cols === 3 ? startY : (startY + i*(cardH+gap));
      rects.push({x:cx,y:cy,w:cardW,h:cardH});
    }
    return {w,h,cols,opts,rects};
  }

  function applyUpgrade(id){
    const now = performance.now();
    if(id==='invuln'){
      state.power.invulnUntil = now + 5000;
      state.power.cdInvuln = 20;
    }
    if(id==='jump'){
      state.power.jumpUntil = now + 5000;
      state.power.cdJump = 20;
    }
    if(id==='slow'){
      state.power.slowUntil = now + 5000;
      state.power.cdSlow = 20;
    }
    if(id==='life'){
      state.lives = Math.min(state.maxLives, state.lives + 1);
      state.power.cdLife = 20;
    }
    playUpgradeSfx(id);
    state.mode = 'play';
  }

  function openUpgrade(){
    const allOpts = [
      { id:'invuln', title:'Invencível', desc:'Sem dano por 5 segundos', disabled: state.power.cdInvuln > 0 },
      { id:'jump', title:'Pulo alto', desc:'Pulo + alto por 5 segundos', disabled: state.power.cdJump > 0 },
      { id:'slow', title:'Mais lento', desc:'Diminui a velocidade por 5 segundos', disabled: state.power.cdSlow > 0 },
      { id:'life', title:'Ganhar vida', desc:'+1 coração (máx 3)', disabled: state.power.cdLife > 0 || state.lives >= state.maxLives }
    ];
    // Sorteia 3 das 4 opções, com menor chance de incluir 'life'
    const includeLife = Math.random() < 0.25; // 25% de chance de incluir vida
    const filtered = includeLife ? allOpts : allOpts.filter(o => o.id !== 'life');
    const shuffled = filtered.sort(() => Math.random() - 0.5);
    const opts = shuffled.slice(0, 3);
    state.upgradeOptions = opts;
    state.mode = 'upgrade';
  }

  function wrapTextCentered(text, x, y, maxWidth, lineHeight, font){
    ctx.font = font;
    const words = String(text).split(' ');
    const lines = [];
    let line = '';
    for(const w of words){
      const test = line ? (line + ' ' + w) : w;
      if(ctx.measureText(test).width > maxWidth && line){
        lines.push(line);
        line = w;
      } else {
        line = test;
      }
    }
    if(line) lines.push(line);
    for(let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], x, y + i*lineHeight);
    }
    return lines.length;
  }

  function drawUpgrade(now){
    const {w,h,opts,rects} = upgradeRects();
    drawBackdrop(w,h,now || performance.now());
    ctx.fillStyle='rgba(0,0,0,0.72)';
    ctx.fillRect(0,0,w,h);

    ctx.fillStyle='#fff';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    let tSize = Math.round(h*0.052);
    ctx.font=`800 ${tSize}px system-ui`;
    while(tSize > 20 && ctx.measureText('ESCOLHA UMA HABILIDADE').width > w*0.92){
      tSize = Math.round(tSize*0.92);
      ctx.font=`800 ${tSize}px system-ui`;
    }
    ctx.fillText('ESCOLHA UMA HABILIDADE', w/2, h*0.14);
    ctx.fillStyle='rgba(255,255,255,0.85)';
    const subFont = `${Math.round(h*0.028)}px system-ui`;
    wrapTextCentered('A cada 10 obstáculos você pode pegar um bônus.', w/2, h*0.20, w*0.86, Math.round(h*0.034), subFont);

    for(let i=0;i<opts.length;i++){
      const o = opts[i];
      const r = rects[i];
      const cx=r.x, cy=r.y, cardW=r.w, cardH=r.h;
      ctx.fillStyle = o.disabled ? 'rgba(255,255,255,0.08)' : 'rgba(255,255,255,0.14)';
      ctx.fillRect(cx,cy,cardW,cardH);
      ctx.strokeStyle = o.disabled ? 'rgba(255,255,255,0.14)' : 'rgba(232,211,172,0.9)';
      ctx.lineWidth = 2;
      ctx.strokeRect(cx,cy,cardW,cardH);

      ctx.fillStyle = o.disabled ? 'rgba(255,255,255,0.45)' : '#fff';
      ctx.font = `800 ${Math.round(cardH*0.22)}px system-ui`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(o.title, cx+cardW/2, cy+cardH*0.30);
      ctx.fillStyle = o.disabled ? 'rgba(255,255,255,0.38)' : 'rgba(255,255,255,0.88)';
      const dFont = `600 ${Math.round(cardH*0.14)}px system-ui`;
      wrapTextCentered(o.desc, cx+cardW/2, cy+cardH*0.50, cardW*0.86, Math.round(cardH*0.15), dFont);
      if(o.disabled){
        ctx.font = `${Math.round(cardH*0.12)}px system-ui`;
        ctx.fillStyle = 'rgba(255,255,255,0.32)';
        const cd = o.id==='invuln' ? state.power.cdInvuln : (o.id==='jump' ? state.power.cdJump : (o.id==='slow' ? state.power.cdSlow : state.power.cdLife));
        ctx.fillText(`Disponível em ${cd}`, cx+cardW/2, cy+cardH*0.82);
      } else {
        ctx.font = `${Math.round(cardH*0.12)}px system-ui`;
        ctx.fillStyle = 'rgba(255,255,255,0.6)';
        ctx.fillText('Toque para pegar', cx+cardW/2, cy+cardH*0.83);
      }
    }
  }

  function pickUpgradeAt(x,y){
    const {opts,rects} = upgradeRects();
    for(let i=0;i<opts.length;i++){
      const o = opts[i];
      const r = rects[i];
      if(x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h){
        if(o.disabled) return true;
        applyUpgrade(o.id);
        return true;
      }
    }
    return false;
  }

  function eventToCanvasXY(e){
    if(!e) return null;
    const rect = cvs.getBoundingClientRect();
    const scaleX = rect.width ? (cvs.clientWidth / rect.width) : 1;
    const scaleY = rect.height ? (cvs.clientHeight / rect.height) : 1;

    let clientX = null;
    let clientY = null;
    if(typeof e.clientX === 'number' && typeof e.clientY === 'number'){
      clientX = e.clientX;
      clientY = e.clientY;
    } else if(e.touches && e.touches[0]){
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else if(e.changedTouches && e.changedTouches[0]){
      clientX = e.changedTouches[0].clientX;
      clientY = e.changedTouches[0].clientY;
    }
    if(clientX === null || clientY === null) return null;
    return {
      x: (clientX - rect.left) * scaleX,
      y: (clientY - rect.top) * scaleY
    };
  }

  function tryJump(e){
    unlockAudio();
    if(state.mode==='upgrade'){
      const p = eventToCanvasXY(e);
      if(p && pickUpgradeAt(p.x, p.y)) return;
      return;
    }
    if(state.mode==='characterSelect'){
      const p = eventToCanvasXY(e);
      if(p){
        const x = p.x;
        const y = p.y;
        if(pickCharacterAt(x,y)) return;
        const br = getStartButtonRect();
        if(x>=br.x && x<=br.x+br.w && y>=br.y && y<=br.y+br.h){
          startGame();
        }
        return;
      }
      return;
    }
    if(state.mode==='menu'){ startGame(); return; }
    if(player.onGround){
      const boost = performance.now() < state.power.jumpUntil ? 1.25 : 1.0;
      player.vy=-world.jump()*boost;
      player.onGround=false;
      try { jumpSound.currentTime = 0; } catch(_) {}
      safePlay(jumpSound);
    }
  }
  cvs.addEventListener('pointerdown', tryJump);
  cvs.addEventListener('touchstart', (e)=>{ try { e.preventDefault(); } catch(_){}; tryJump(e); }, {passive:false});
  window.addEventListener('keydown', e=>{ if(e.code==='Space'||e.code==='ArrowUp'){ e.preventDefault(); tryJump(); } }, {passive:false});
  document.getElementById('reset').onclick = ()=>{
    state.hi = 0;
    state.score = 0;
    bestCharacterId = '';
    bestCharacterScore = 0;
    for (const k of Object.keys(bestByCharacter)) delete bestByCharacter[k];
    localStorage.setItem('dino_hi','0');
    localStorage.setItem('dino_best_by_character', JSON.stringify(bestByCharacter));
    localStorage.setItem('dino_best_character_id', '');
    localStorage.setItem('dino_best_character_score', '0');
    document.getElementById('hi').textContent='0';
    document.getElementById('sc').textContent='0';
  };

  let last=performance.now();
  function loop(now){
    try {
      const dt=Math.min(0.032,(now-last)/1000); last=now;
      // Garante que o modo seja 'play' se estiver undefined
      if(!state.mode) state.mode='play';
      if(state.mode==='characterSelect'){
        drawCharacterSelect(now);
        requestAnimationFrame(loop); return;
      }
      if(state.mode==='upgrade'){
        drawUpgrade(now);
        requestAnimationFrame(loop); return;
      }
      if(state.mode==='menu'){
        drawMenu();
        requestAnimationFrame(loop); return;
      }

    
    // ====== JOGO ======
    // Tocar música de fundo se não estiver tocando
    if (!bgMusic.playing && state.mode === 'play') {
      safePlay(bgMusic);
      bgMusic.playing = true;
    }
    
    const w=cvs.clientWidth,h=cvs.clientHeight;

    const ph = phases[Math.max(0, Math.min(phases.length-1, state.phase))];
    const grad = ctx.createLinearGradient(0,0,0,h);
    grad.addColorStop(0, ph.bg[0]);
    grad.addColorStop(1, ph.bg[1]);
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,w,h);

    drawSun(w, h, state.weather);

    // HUD será desenhado no final (por cima da chuva)

    // relâmpago (temporal)
    if(state.weather && (state.weather.type === 'storm')) {
      if(now >= state.nextLightningAt) {
        state.lightning = 0.65 + Math.random()*0.35;
        state.nextLightningAt = now + 2500 + Math.random()*5000;
        // volume do trovão acompanha a intensidade do tema (chuva/temporal)
        const stormStrength = Math.max(0, Math.min(1, (state.weather.rain || 0.85)));
        playLightningCrack(0.75 + 0.25*stormStrength);
        playThunder(0.65 + 0.35*stormStrength);
      }
    }
    if(state.lightning > 0) state.lightning = Math.max(0, state.lightning - dt*0.9);

    const invulnOn = now < state.power.invulnUntil;
    const jumpOn = now < state.power.jumpUntil;
    const slowOn = now < state.power.slowUntil;
    const speedEff = world.speed * (slowOn ? 0.85 : 1.0);

    for(const c of world.clouds){
      const sp = (c.layer===0 ? 0.18 : 0.35) * speedEff * dt;
      c.x -= sp;
      if(c.x + c.r*2 < 0){
        c.x = w + c.r*2;
        c.band = c.band || (Math.random() < 0.65 ? 'high' : 'low');
        c.y = c.band === 'low' ? (h*0.18 + Math.random()*h*0.38) : (Math.random()*h*0.32);
        c.r = c.band === 'low' ? (24 + Math.random()*58) : (18 + Math.random()*42);
        c.layer = Math.random()<0.5 ? 0 : 1;
      }
      const a = c.band === 'low' ? (c.layer===0 ? 0.48 : 0.62) : (c.layer===0 ? 0.38 : 0.52);
      ctx.fillStyle = `rgba(255,255,255,${a})`;
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.r*0.55, 0, Math.PI*2);
      ctx.arc(c.x + c.r*0.55, c.y + c.r*0.1, c.r*0.65, 0, Math.PI*2);
      ctx.arc(c.x + c.r*1.1, c.y, c.r*0.5, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = `rgba(240,245,255,${a*0.45})`;
      ctx.beginPath();
      ctx.arc(c.x + c.r*0.25, c.y + c.r*0.05, c.r*0.42, 0, Math.PI*2);
      ctx.arc(c.x + c.r*0.80, c.y + c.r*0.08, c.r*0.48, 0, Math.PI*2);
      ctx.fill();
    }

    drawBirds(w, h, state.weather, now);

    // chão temático
    if(state.weather && state.weather.rain > 0) {
      drawRainLayer(w, h, now, state.weather.rain, state.weather.type === 'storm', 0.9, 1.0, 1.0, 1.0);
    }

    drawGround(w, h, ph, state.weather, now*speedEff);

    // respingos de chuva no chão (após desenhar o chão)
    if(state.weather && state.weather.rain > 0 && state.weather.type === 'storm' && state.weather.rain > 0.7) {
      ctx.save();
      ctx.strokeStyle = `rgba(200,220,255,${0.15 + state.weather.rain*0.10})`;
      ctx.lineWidth = 1;
      for(let i=0;i<15;i++){
        const x = (Math.random()*w + now*0.1) % w;
        const y = GY() + UNIT()*0.5 + (Math.random()*20);
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - 3, y - 3);
        ctx.stroke();
      }
      ctx.restore();
    }

    // neblina / tint
    if(state.weather) {
      if(state.weather.fog > 0) {
        const a = state.weather.fog;
        ctx.fillStyle = `rgba(235,245,255,${a})`;
        ctx.fillRect(0,0,w,h);
      }
      if(state.weather.tint && state.weather.tint !== 'rgba(0,0,0,0)') {
        ctx.fillStyle = state.weather.tint;
        ctx.fillRect(0,0,w,h);
      }
    }

    // flash de relâmpago por cima de tudo
    if(state.lightning > 0) {
      const a = Math.max(0, Math.min(1, state.lightning));
      ctx.fillStyle = `rgba(255,255,255,${a})`;
      ctx.fillRect(0,0,w,h);
      // segunda passada para ficar bem branco/forte
      ctx.fillStyle = `rgba(255,255,255,${a*0.6})`;
      ctx.fillRect(0,0,w,h);
    }

    // animação
    if(SHEETS[CHARACTERS[currentCharacter]?.sheetId || 'sprite1']?.spr?.ready){
      const rf = runFrameAt(now);
      player.f = player.onGround ? rf : 2;
    }

    // física
    player.vy += world.gravity()*dt; player.y += player.vy*dt;
    const gy = GY() - 3.4*UNIT(); if(player.y>=gy){ player.y=gy; player.vy=0; player.onGround=true; } else player.onGround=false;

    // velocidade linear (com fase)
    world.speed += 0.12*UNIT()*dt * ph.speedMul;

    // obstáculos
    world.dist -= speedEff*dt;
    if(world.dist<=0){
      world.dist=UNIT()*(26+Math.random()*12) * ph.spawnMul;
      spawn();
    }
    
    
    for(const o of world.obstacles){
      o.x -= speedEff*dt;
      
      const cactus = (cactusImages && cactusImages[o.cactusIndex || 0]) ? cactusImages[o.cactusIndex || 0] : null;
      if (cactus && cactus.complete) {
        const ratio = cactus.naturalHeight / cactus.naturalWidth;
        const drawW = o.w;
        const drawH = drawW * ratio;
        ctx.drawImage(cactus, o.x, o.y - (drawH - o.h), drawW, drawH);
      } else {
        ctx.fillStyle='#2e7d32';
        ctx.fillRect(o.x,o.y,o.w,o.h);
      }
    
      if (!o.passed && o.x + o.w < PLAYER_X) {
        o.passed = true;
        state.score++;
        if(state.power.cdInvuln > 0) state.power.cdInvuln--;
        if(state.power.cdJump > 0) state.power.cdJump--;
        if(state.power.cdSlow > 0) state.power.cdSlow--;
        if(state.power.cdLife > 0) state.power.cdLife--;
        const tNow = performance.now();
        if(tNow - state.lastPointAt > 80) {
          try { pointSound.currentTime = 0; } catch(_) {}
          safePlay(pointSound);
          state.lastPointAt = tNow;
        }
        if (state.score > state.hi) {
          state.hi = state.score;
          localStorage.setItem('dino_hi', state.hi.toString());
        }
        document.getElementById('sc').textContent = state.score;

        // record por personagem + quem foi mais longe
        const prev = Number(bestByCharacter[currentCharacter] || 0);
        if(state.score > prev) {
          bestByCharacter[currentCharacter] = state.score;
          localStorage.setItem('dino_best_by_character', JSON.stringify(bestByCharacter));
        }
        if(state.score > bestCharacterScore) {
          bestCharacterScore = state.score;
          bestCharacterId = currentCharacter;
          localStorage.setItem('dino_best_character_id', bestCharacterId);
          localStorage.setItem('dino_best_character_score', String(bestCharacterScore));
          document.getElementById('hi').textContent = String(bestCharacterScore || 0);
        }

        if(state.score >= state.upgradeAt) {
          state.upgradeAt += 10;
          openUpgrade();
        }

        // fases
        if(state.score >= state.nextPhaseAt) {
          state.phase = Math.min(phases.length-1, state.phase + 1);
          state.phaseOverlay = 4.4;
          state.nextPhaseAt += 10;
          try { phaseSound.currentTime = 0; } catch(_) {}
          safePlay(phaseSound);
        }
      }
    }
    
    world.obstacles = world.obstacles.filter(o=>o.x+o.w>-20);

    // desenha sprite (e calcula retângulo do player para colisão)
    const ch = CHARACTERS[currentCharacter];
    const s = SHEETS[ch?.sheetId || 'sprite1'];
    const u = UNIT();
    const pw = 4.2*u;
    let sprW = pw*player.scale;
    let sprH = sprW*0.8;
    const baseY = player.y + pw;
    const destX = PLAYER_X;
    let destY = baseY - sprH;

    if(s?.spr?.ready && s?.img){
      const SPR = s.spr;
      sprH = sprW*(SPR.h/SPR.w);
      destY = baseY - sprH;
      const r = frameRectFor(currentCharacter, player.f);
      const nowFx = performance.now();
      const invOn = nowFx < state.power.invulnUntil;
      const jOn = nowFx < state.power.jumpUntil;
      const slOn = nowFx < state.power.slowUntil;
      if(invOn){
        ctx.save();
        ctx.globalAlpha = 0.70;
        ctx.drawImage(s.img, r.sx, r.sy, r.sw, r.sh, destX, destY, sprW, sprH);
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.55;
        ctx.fillStyle = 'rgba(56,189,248,1)';
        ctx.fillRect(destX, destY, sprW, sprH);
        ctx.restore();
      } else if(jOn){
        ctx.save();
        ctx.globalCompositeOperation = 'screen';
        ctx.globalAlpha = 0.22;
        ctx.fillStyle = 'rgba(250,204,21,1)';
        ctx.fillRect(destX-2, destY-2, sprW+4, sprH+4);
        ctx.restore();
        ctx.drawImage(s.img, r.sx, r.sy, r.sw, r.sh, destX, destY, sprW, sprH);
      } else if(slOn){
        ctx.save();
        ctx.globalAlpha = 0.92;
        ctx.drawImage(s.img, r.sx, r.sy, r.sw, r.sh, destX, destY, sprW, sprH);
        ctx.globalCompositeOperation = 'multiply';
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = 'rgba(34,197,94,1)';
        ctx.fillRect(destX, destY, sprW, sprH);
        ctx.restore();
      } else {
        ctx.drawImage(s.img, r.sx, r.sy, r.sw, r.sh, destX, destY, sprW, sprH);
      }
    } else {
      // Fallback: desenha retângulo simples se sprite não carregou
      ctx.fillStyle = '#4a4a4a';
      ctx.fillRect(destX, destY, sprW, sprH);
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(destX + sprW*0.7, destY + sprH*0.2, 4, 4);
    }

    // colisão: AABB simples (reduz 1 vida)
    for(let i = world.obstacles.length - 1; i >= 0; i--){
      const o = world.obstacles[i];
      if(destX < o.x + o.w && destX + sprW > o.x && destY < o.y + o.h && destY + sprH > o.y){
        if(performance.now() < state.power.invulnUntil) break;
        state.lives = Math.max(0, state.lives - 1);
        try { hitSound.currentTime = 0; } catch(_) {}
        safePlay(hitSound);
        world.obstacles.splice(i, 1);
        if(state.lives <= 0){
          state.mode='characterSelect';
          hud.style.display='none';
          bgMusic.pause();
          bgMusic.playing = false;
          try { introSound.currentTime = 0; } catch(_) {}
          safePlay(introSound);
          stopRainSfx();
        }
        break;
      }
    }

    if(state.weather && state.weather.rain > 0) {
      drawRainLayer(w, h, now, state.weather.rain, state.weather.type === 'storm', 1.0, 1.15, 1.1, 1.05);
    }

    drawGameHUD(w, h);

    // overlay de fase
    if(state.phaseOverlay > 0) {
      state.phaseOverlay -= dt;
      const p = phases[Math.max(0, Math.min(phases.length-1, state.phase))];
      ctx.save();
      ctx.globalAlpha = Math.min(1, state.phaseOverlay);
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.fillRect(0,0,w,h);
      ctx.fillStyle = '#fff';
      ctx.font = `bold ${Math.round(h*0.08)}px system-ui`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(p.name, w/2, h*0.18);
      ctx.restore();
    }

    requestAnimationFrame(loop);
    } catch (e) {
      console.error('Erro no loop do jogo:', e);
      requestAnimationFrame(loop);
    }
  }
  

// === Cálculo de bounds por alpha para obstáculos (como feito no sprite) ===
function computeObstacleBounds(img){
  const w = img.naturalWidth, h = img.naturalHeight;
  const off = document.createElement('canvas'); off.width=w; off.height=h;
  const octx = off.getContext('2d', { willReadFrequently:true }); octx.imageSmoothingEnabled=false;
  octx.clearRect(0,0,w,h);
  octx.drawImage(img,0,0,w,h);
  const d = octx.getImageData(0,0,w,h).data;
  let minX=w,minY=h,maxX=0,maxY=0,found=false;
  for(let y=0;y<h;y++){ for(let x=0;x<w;x++){ if(d[(y*w+x)*4+3]>10){ if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; found=true; } } }
  if(!found) return {ox:0.1, oy:0.1, ow:0.8, oh:0.8};
  const shrinkX=0.05, shrinkY=0.05;
  let ox=minX/w, oy=minY/h, ow=(maxX-minX+1)/w, oh=(maxY-minY+1)/h;
  ox+=shrinkX; ow-=shrinkX*2; oy+=shrinkY; oh-=shrinkY*2;
  return {ox,oy,ow,oh};
}


requestAnimationFrame(loop);
})();
</script>
</body>
</html>